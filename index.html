<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Speculative Trade Advisor (Free, GDELT)</title>
  <style>
    :root{
      --bg:#0b0f17; --panel:#0e162a; --panel2:#0b1020;
      --border:#1d2a44; --border2:#233357;
      --text:#e8eefc; --muted:rgba(232,238,252,.72);
      --accent:#2a5cff; --bad:#ff8080; --ok:#93ffb4; --warn:#ffd38a;
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
    }
    body{margin:0;background:var(--bg);color:var(--text);}
    header{padding:18px 18px;border-bottom:1px solid var(--border);background:#0b1020;}
    header h1{margin:0 0 6px;font-size:18px;}
    header p{margin:0;color:var(--muted);font-size:13px;line-height:1.35;}
    main{padding:16px 18px;max-width:1280px;margin:0 auto;}
    .grid{display:grid;grid-template-columns:1fr;gap:12px;}
    @media(min-width:1040px){.grid{grid-template-columns:460px 1fr;}}
    .card{background:var(--panel);border:1px solid var(--border);border-radius:14px;padding:14px;}
    label{display:block;font-size:12px;color:var(--muted);margin:10px 0 6px;}
    input,select,textarea,button{
      width:100%;box-sizing:border-box;border-radius:12px;border:1px solid var(--border2);
      background:var(--panel2);color:var(--text);padding:10px 11px;font-size:14px;
    }
    textarea{min-height:90px;resize:vertical;}
    .row{display:grid;grid-template-columns:1fr 1fr;gap:10px;}
    .row3{display:grid;grid-template-columns:1fr 1fr 1fr;gap:10px;}
    .actions{display:grid;grid-template-columns:1fr 1fr;gap:10px;margin-top:12px;}
    button{cursor:pointer;font-weight:700;}
    button.primary{background:var(--accent);border-color:var(--accent);}
    button.ghost{background:transparent;}
    button:disabled{opacity:.65;cursor:not-allowed;}
    .status{margin-top:10px;font-size:13px;color:var(--muted);}
    .status.error{color:var(--bad);}
    .status.warn{color:var(--warn);}
    .pillbar{display:flex;flex-wrap:wrap;gap:8px;margin-top:10px;}
    .pill{border:1px solid var(--border2);background:var(--panel2);padding:5px 9px;border-radius:999px;font-size:12px;color:var(--muted);}
    .rightHead{display:flex;align-items:flex-end;justify-content:space-between;gap:12px;margin-bottom:10px;}
    .rightHead h2{margin:0;font-size:16px;}
    .rightHead .small{font-size:12px;color:var(--muted);}
    .tabs{display:flex;gap:8px;flex-wrap:wrap;margin:0 0 10px;}
    .tab{padding:8px 10px;border-radius:999px;border:1px solid var(--border2);background:var(--panel2);font-size:12px;color:var(--muted);cursor:pointer;user-select:none;}
    .tab.active{border-color:var(--accent);color:var(--text);}
    .results{display:grid;gap:10px;}
    .item{border-radius:14px;border:1px solid var(--border);background:var(--panel2);padding:12px;}
    .item .title{margin:0 0 6px;font-weight:800;line-height:1.25;}
    .item a{color:#9dc0ff;text-decoration:none;}
    .item a:hover{text-decoration:underline;}
    .sub{display:flex;gap:10px;flex-wrap:wrap;font-size:12px;color:var(--muted);}
    .scoreline{display:flex;gap:10px;flex-wrap:wrap;margin-top:8px;font-size:12px;color:var(--muted);}
    .badge{display:inline-flex;align-items:center;gap:6px;border:1px solid var(--border2);background:#0b1020;padding:4px 8px;border-radius:999px;}
    .dot{width:8px;height:8px;border-radius:999px;background:var(--muted);display:inline-block;}
    .dot.ok{background:var(--ok);}
    .dot.bad{background:var(--bad);}
    .dot.warn{background:var(--warn);}
    .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace;}
    .smallnote{font-size:12px;color:var(--muted);line-height:1.35;margin-top:10px;}
    .hr{height:1px;background:var(--border);margin:10px 0;}
    .sliderwrap{display:grid;grid-template-columns:1fr 90px;gap:10px;align-items:center;}
    input[type="range"]{padding:0;height:36px;}
    .minirow{display:grid;grid-template-columns:1fr 1fr 1fr;gap:10px;margin-top:10px;}
    .planGrid{display:grid;grid-template-columns:1fr;gap:10px;margin-top:10px;}
    @media(min-width:980px){.planGrid{grid-template-columns:1fr 1fr 1fr;}}
    .planCard{border:1px solid var(--border);background:#0b1020;border-radius:14px;padding:12px;}
    .planCard h3{margin:0 0 8px;font-size:14px;}
    .planOut{font-size:12px;color:var(--muted);line-height:1.45;margin-top:8px;}
  </style>
</head>

<body>
<header>
  <h1>Speculative Trade Advisor (Free, GDELT)</h1>
  <p>
    Free-only scanner: fetches headlines (GDELT DOC 2.0), filters to trusted English sources locally, scores tradability (1–10),
    ranks 3 candidates for a ~15–20 trading day event window, and produces a discipline-compliant trade plan (manual price input).
    Research tool only. Not investment advice.
  </p>
</header>

<main class="grid">
  <!-- LEFT: Controls -->
  <section class="card">
    <div class="row">
      <div>
        <label>Lookback (TIMESPAN)</label>
        <select id="timespan">
          <option value="1h">Last 1 hour</option>
          <option value="6h">Last 6 hours</option>
          <option value="12h" selected>Last 12 hours</option>
          <option value="1day">Last 1 day</option>
          <option value="3day">Last 3 days</option>
          <option value="1week">Last 1 week</option>
        </select>
      </div>
      <div>
        <label>Sort</label>
        <select id="sort">
          <option value="datedesc" selected>Date (newest first)</option>
          <option value="">Relevance</option>
          <option value="toneasc">Tone (most negative)</option>
          <option value="tonedesc">Tone (most positive)</option>
        </select>
      </div>
    </div>

    <div class="row3">
      <div>
        <label>Headlines / topic (after filter)</label>
        <input id="perTopic" type="number" min="1" max="25" value="5" />
      </div>
      <div>
        <label>Concurrency</label>
        <input id="concurrency" type="number" min="1" max="10" value="4" />
      </div>
      <div>
        <label>Time zone display</label>
        <select id="tz">
          <option value="Asia/Jerusalem" selected>Asia/Jerusalem</option>
          <option value="UTC">UTC</option>
          <option value="America/New_York">America/New_York</option>
          <option value="Europe/London">Europe/London</option>
        </select>
      </div>
    </div>

    <label>Strictness (0 = Idea Mode, 100 = Strict)</label>
    <div class="sliderwrap">
      <input id="strictness" type="range" min="0" max="100" value="45" />
      <input id="strictnessNum" type="number" min="0" max="100" value="45" />
    </div>
    <div class="pillbar" style="margin-top:8px;">
      <div class="pill" id="modePill">Mode: Balanced</div>
      <div class="pill">Locked: sourcelang:english</div>
    </div>

    <div class="row">
      <div>
        <label>Optional filter (applies to all topics)</label>
        <input id="country" placeholder="sourcecountry (e.g. unitedstates)" />
      </div>
      <div>
        <label>Oversample factor (fetch more before filtering)</label>
        <select id="oversample">
          <option value="3">x3</option>
          <option value="4" selected>x4</option>
          <option value="6">x6</option>
          <option value="8">x8</option>
        </select>
      </div>
    </div>

    <label>Trusted sources preset</label>
    <select id="preset">
      <option value="expanded" selected>Expanded trusted (recommended)</option>
      <option value="core">Core wires only (very strict)</option>
      <option value="off">Off (no domain filtering)</option>
    </select>

    <label>Domain matching (local filter)</label>
    <select id="domainMatch">
      <option value="broad" selected>Broad match (recommended, fewer “no results”)</option>
      <option value="exact">Exact match only</option>
    </select>

    <label>Trusted domains allowlist (LOCAL filter)</label>
    <textarea id="allowlist" spellcheck="false"></textarea>
    <div class="actions">
      <button id="resetListBtn" class="ghost">Reset to Preset</button>
      <button id="saveListBtn" class="ghost">Save List</button>
    </div>

    <div class="hr"></div>

    <div class="row">
      <div>
        <label>Capital per trade ($)</label>
        <input id="capital" type="number" min="1000" max="2000" value="1500" />
      </div>
      <div>
        <label>Fee per executed order ($)</label>
        <input id="fee" type="number" min="0" max="50" value="8" />
      </div>
    </div>
    <div class="smallnote">
      Trade plan math assumes 2 executed orders (entry + exit) = 2 × fee. Tax assumed 25% on net gains.
      No live prices are used: you enter “current price” for each candidate.
    </div>

    <div class="hr"></div>

    <label>Optional: custom topic query override (advanced)</label>
    <textarea id="customQuery" placeholder='Leave blank. Example: ("sanctions" OR "export controls")'></textarea>

    <div class="actions">
      <button id="runBtn" class="primary">Run Scan</button>
      <button id="exportBtn" class="ghost" disabled>Export JSON</button>
    </div>

    <div class="actions">
      <button id="saveBtn" class="ghost" disabled>Save to History</button>
      <button id="clearHistoryBtn" class="ghost">Clear History</button>
    </div>

    <div id="status" class="status"></div>
    <div id="pills" class="pillbar"></div>

    <div class="hr"></div>

    <label>History (localStorage)</label>
    <select id="history"></select>
    <div class="smallnote">Select a past scan to re-load its results without re-fetching news.</div>
  </section>

  <!-- RIGHT: Results -->
  <section class="card">
    <div class="rightHead">
      <h2>Results</h2>
      <div id="meta" class="small"></div>
    </div>

    <div class="tabs">
      <div class="tab active" data-tab="decision">Trade Decision</div>
      <div class="tab" data-tab="headlines">Headlines by Topic</div>
      <div class="tab" data-tab="tickers">Ticker Table</div>
      <div class="tab" data-tab="diag">Diagnostics</div>
      <div class="tab" data-tab="method">Method</div>
    </div>

    <div id="viewDecision" class="results"></div>
    <div id="viewHeadlines" class="results" style="display:none;"></div>
    <div id="viewTickers" class="results" style="display:none;"></div>
    <div id="viewDiag" class="results" style="display:none;"></div>
    <div id="viewMethod" class="results" style="display:none;"></div>
  </section>
</main>

<script>
(() => {
  // ========= Endpoint =========
  // IMPORTANT: must be absolute (https://...). If you later decide to use a Cloudflare Worker proxy,
  // replace this with the worker URL.
  const GDELT_ENDPOINT = "https://api.gdeltproject.org/api/v2/doc/doc";

  // ========= Universe =========
  const TICKER_GROUPS = {
    defense: ["PPA","ITA","LMT","NOC","GD","RTX","BA","HII","LHX","TDG","AVAV","KTOS"],
    cyber: ["CIBR","HACK","PANW","CRWD","FTNT","ZS","OKTA","NET"],
    semis: ["SMH","SOXX","NVDA","AVGO","TSM","MU","ASML","AMAT","LRCX","KLAC","AMD","ARM","MRVL"],
    energy: ["XLE","XOP","LNG","VLO","CVX","XOM","SLB","HAL","OIH"],
    shipping: ["INSW","STNG","TK","ZIM","DAC"],
    uranium: ["URNM","URA","CCJ","UEC","LEU"],
    water_agri: ["PHO","MOO","DBA","NTR","MOS","CF","DE"],
    insurers: ["KIE","CB","TRV","ALL","AIG"],
    gold: ["GLD","IAU","GDX"]
  };

  const ETF_SET = new Set([
    "PPA","ITA","CIBR","HACK","SMH","SOXX","XLE","XOP","OIH","KIE","URNM","URA","PHO","MOO","DBA","GLD","IAU","GDX"
  ]);

  // ========= Topics =========
  const TOPICS = [
    { key:"geopolitics", label:"geopolitics", terms:['geopolitics','"regional tensions"','"border clash"','"military buildup"','"diplomatic crisis"'] },
    { key:"sanctions", label:"sanctions", terms:['sanctions','"export controls"','"blacklist"','"secondary sanctions"','"asset freeze"'] },
    { key:"ceasefire", label:"ceasefire", terms:['ceasefire','truce','"peace talks"','"temporary halt"'] },
    { key:"war", label:"war", terms:['war','airstrike','missile','"ground offensive"','"troop deployment"'] },
    { key:"regulation", label:"regulation", terms:['regulation','"regulatory crackdown"','antitrust','"compliance rule"','SEC','FTC'] },
    { key:"tariff", label:"tariff", terms:['tariff','"trade war"','"import duty"','"export ban"'] },
    { key:"cyber", label:"cyber", terms:['cyber','ransomware','"data breach"','DDoS','"zero-day"','hackers'] },
    { key:"earthquake", label:"earthquake", terms:['earthquake','seismic','aftershock','magnitude'] },
    { key:"flood", label:"flood", terms:['flood','"flash flood"','"storm surge"','"river overflow"'] },
    { key:"wildfire", label:"wildfire", terms:['wildfire','"forest fire"','"evacuation order"','burning'] },
    { key:"inflation", label:"inflation", terms:['inflation','CPI','PCE','"price pressures"','"core inflation"'] },
    { key:"rates", label:"rates", terms:['"interest rate"','"rate hike"','"rate cut"','"policy rate"','"Federal Reserve"','ECB','BoE'] },
    { key:"recession", label:"recession", terms:['recession','"GDP contraction"','"yield curve"','"job losses"','"hard landing"'] },
    { key:"OPEC", label:"OPEC", terms:['OPEC','"OPEC+"','"oil output"','"production cut"','quota'] },
    { key:"oil", label:"oil", terms:['"crude oil"','Brent','WTI','"oil prices"','"oil supply"'] }
  ];

  // Topic -> sector weights (beneficiary bias for long-only “who benefits”)
  const TOPIC_SECTOR_WEIGHTS = {
    geopolitics: { defense:0.8, energy:0.6, shipping:0.5, gold:0.6, insurers:0.2 },
    sanctions:   { energy:0.5, shipping:0.5, defense:0.4, semis:0.25, gold:0.3 },
    ceasefire:   { shipping:0.6, energy:0.25, gold:0.15, defense:0.15 },
    war:         { defense:0.9, energy:0.6, gold:0.7, shipping:0.4 },
    regulation:  { insurers:0.35, semis:0.25, energy:0.2 },
    tariff:      { semis:0.45, shipping:0.35, energy:0.2 },
    cyber:       { cyber:0.95 },
    earthquake:  { insurers:0.25, water_agri:0.25, energy:0.15 },
    flood:       { insurers:0.25, water_agri:0.35, energy:0.15 },
    wildfire:    { insurers:0.25, water_agri:0.35, energy:0.15 },
    inflation:   { gold:0.35, insurers:0.25, energy:0.2 },
    rates:       { insurers:0.35, gold:0.25 },
    recession:   { gold:0.45, insurers:0.25 },
    OPEC:        { energy:0.9, shipping:0.35 },
    oil:         { energy:0.85, shipping:0.3 }
  };

  // Heuristic Liquidity scores (0..1)
  const LIQ = Object.fromEntries([
    ["PPA",0.75],["ITA",0.8],["CIBR",0.8],["HACK",0.7],["SMH",0.85],["SOXX",0.85],
    ["XLE",0.9],["XOP",0.75],["OIH",0.6],["KIE",0.65],["URNM",0.55],["URA",0.65],
    ["PHO",0.55],["MOO",0.55],["DBA",0.6],["GLD",0.95],["IAU",0.85],["GDX",0.75],
    ["NVDA",0.95],["AVGO",0.9],["TSM",0.9],["AMD",0.9],["XOM",0.9],["CVX",0.85],
    ["BA",0.85],["RTX",0.8],["LMT",0.75],["PANW",0.8],["CRWD",0.8],["NET",0.75],
    ["AVAV",0.55],["KTOS",0.5],["HII",0.45],["INSW",0.45],["STNG",0.5],["TK",0.4],
    ["ZIM",0.6],["DAC",0.45],["UEC",0.45],["LEU",0.45],["CCJ",0.6],["LNG",0.75],["VLO",0.75],
    ["SLB",0.8],["HAL",0.7],["OIH",0.6]
  ]);

  // Heuristic Volatility scores (0..1)
  const VOL = Object.fromEntries([
    ["NVDA",0.9],["AMD",0.85],["ARM",0.85],["MRVL",0.8],["MU",0.85],
    ["XOP",0.8],["OIH",0.85],["HAL",0.75],["SLB",0.7],["XLE",0.55],
    ["ZIM",0.9],["STNG",0.75],["INSW",0.6],
    ["CRWD",0.8],["PANW",0.65],["NET",0.75],["FTNT",0.65],
    ["GLD",0.35],["GDX",0.6],["IAU",0.3],
    ["LMT",0.35],["NOC",0.35],["RTX",0.4],["BA",0.6],["KTOS",0.7],["AVAV",0.65],
    ["KIE",0.35],["AIG",0.45],["ALL",0.35]
  ]);

  const DEFAULT_LIQ = 0.55;
  const DEFAULT_VOL = 0.55;

  // ========= Trusted domain presets =========
  const PRESETS = {
    expanded: [
      "reuters.com","apnews.com","bloomberg.com","wsj.com","ft.com","economist.com",
      "cnbc.com","marketwatch.com","nytimes.com","washingtonpost.com","theguardian.com",
      "bbc.co.uk","bbc.com","aljazeera.com",
      "politico.com","axios.com","thehill.com",
      "defensenews.com","breakingdefense.com",
      "cisa.gov","fbi.gov","nsa.gov","nvd.nist.gov",
      "opec.org","iea.org","eia.gov","imf.org","worldbank.org",
      "sec.gov","europa.eu","ec.europa.eu"
    ],
    core: [
      "reuters.com","apnews.com","bbc.co.uk","bbc.com","ft.com","wsj.com","bloomberg.com"
    ]
  };

  // ========= UI =========
  const el = {
    timespan: document.getElementById("timespan"),
    sort: document.getElementById("sort"),
    perTopic: document.getElementById("perTopic"),
    concurrency: document.getElementById("concurrency"),
    tz: document.getElementById("tz"),
    strictness: document.getElementById("strictness"),
    strictnessNum: document.getElementById("strictnessNum"),
    modePill: document.getElementById("modePill"),
    country: document.getElementById("country"),
    oversample: document.getElementById("oversample"),
    preset: document.getElementById("preset"),
    domainMatch: document.getElementById("domainMatch"),
    allowlist: document.getElementById("allowlist"),
    resetListBtn: document.getElementById("resetListBtn"),
    saveListBtn: document.getElementById("saveListBtn"),
    capital: document.getElementById("capital"),
    fee: document.getElementById("fee"),
    customQuery: document.getElementById("customQuery"),
    runBtn: document.getElementById("runBtn"),
    exportBtn: document.getElementById("exportBtn"),
    saveBtn: document.getElementById("saveBtn"),
    clearHistoryBtn: document.getElementById("clearHistoryBtn"),
    status: document.getElementById("status"),
    pills: document.getElementById("pills"),
    meta: document.getElementById("meta"),
    history: document.getElementById("history"),
    viewDecision: document.getElementById("viewDecision"),
    viewHeadlines: document.getElementById("viewHeadlines"),
    viewTickers: document.getElementById("viewTickers"),
    viewDiag: document.getElementById("viewDiag"),
    viewMethod: document.getElementById("viewMethod")
  };

  let lastScan = null;

  // ========= Helpers =========
  const clamp01 = (x) => Math.max(0, Math.min(1, x));
  const round2 = (x) => Math.round(x * 100) / 100;

  function setStatus(msg, kind=""){
    el.status.textContent = msg || "";
    el.status.className = "status" + (kind ? ` ${kind}` : "");
  }

  function setPills(pairs){
    el.pills.innerHTML = "";
    for(const [k,v] of pairs){
      const d = document.createElement("div");
      d.className = "pill";
      d.textContent = `${k}: ${v}`;
      el.pills.appendChild(d);
    }
  }

  function escapeHtml(s){
    return String(s ?? "")
      .replaceAll("&","&amp;").replaceAll("<","&lt;").replaceAll(">","&gt;")
      .replaceAll('"',"&quot;").replaceAll("'","&#039;");
  }

  function fmtDate(dt, tz){
    try{
      return new Intl.DateTimeFormat(undefined, {
        timeZone: tz, year:"numeric", month:"2-digit", day:"2-digit",
        hour:"2-digit", minute:"2-digit", second:"2-digit"
      }).format(dt);
    }catch{
      return dt.toISOString();
    }
  }

  function normDomain(d){
    d = (d || "").toLowerCase().trim();
    if(d.startsWith("www.")) d = d.slice(4);
    return d;
  }

  function getAllowlist(){
    const preset = el.preset.value;
    if(preset === "off") return [];
    const raw = el.allowlist.value.split("\n").map(x => normDomain(x)).filter(Boolean);
    // de-dup
    return Array.from(new Set(raw));
  }

  function domainAllowed(domain, allow, mode){
    if(!allow.length) return true;
    const d = normDomain(domain);
    if(!d) return false;
    if(mode === "exact"){
      return allow.includes(d);
    }
    // broad: allow if endsWith any allow entry
    return allow.some(a => d === a || d.endsWith("." + a) || d.endsWith(a));
  }

  // Build query: (terms) sourcelang:english [sourcecountry:...]
  function buildQueryFromTerms(terms, country){
    const core = "(" + terms.join(" OR ") + ")";
    let q = core + " sourcelang:english";
    if(country) q += ` sourcecountry:${country}`;
    return q.trim();
  }

  function buildGdeltUrl({ query, timespan, sort, maxrecords }){
    // Ensure absolute URL. If someone accidentally sets a relative endpoint, this makes it obvious.
    const url = new URL(GDELT_ENDPOINT);
    url.searchParams.set("query", query);
    url.searchParams.set("mode", "artlist");
    url.searchParams.set("format", "json");
    url.searchParams.set("timespan", timespan);
    url.searchParams.set("maxrecords", String(maxrecords));
    if(sort) url.searchParams.set("sort", sort);
    return url.toString();
  }

  async function mapLimit(items, limit, worker){
    const results = new Array(items.length);
    let i = 0;
    const runners = Array.from({length: Math.max(1, limit)}, async () => {
      while(i < items.length){
        const idx = i++;
        results[idx] = await worker(items[idx], idx);
      }
    });
    await Promise.all(runners);
    return results;
  }

  function parseGdeltSeenDate(s){
    if(!s) return null;
    const iso = String(s).replace(" ", "T") + "Z";
    const d = new Date(iso);
    return isNaN(d) ? null : d;
  }

  // ========= Scoring =========
  function catalystClarity(title){
    const t = (title || "").toLowerCase();
    let score = 0.18;

    const hasNumber = /(\d+(\.\d+)?)|(%|\$|bps|basis points|million|billion|mbpd)/i.test(title || "");
    if(hasNumber) score += 0.18;

    const actionVerbs = [
      "announces","imposes","approve","approved","ban","bans","halts","suspends","launches","strike","strikes","attack","attacks",
      "cuts","raises","hikes","slashes","warns","sanction","sanctions","tariff","export controls","ceasefire",
      "breach","ransomware","hack","exploit","zero-day","earthquake","flood","wildfire"
    ];
    for(const w of actionVerbs){
      if(t.includes(w)) score += 0.03;
    }

    const specificityHints = ["opec","opec+","fed","ecb","boe","cpi","pce","brent","wti","pipeline","shipping lane","red sea","strait","export ban"];
    for(const w of specificityHints){
      if(t.includes(w)) score += 0.05;
    }

    const vague = ["what you need to know","explainer","analysis","opinion","live updates"];
    for(const w of vague){
      if(t.includes(w)) score -= 0.05;
    }

    return clamp01(score);
  }

  function timingScore(seenDateUtc, nowUtc){
    if(!seenDateUtc || !(seenDateUtc instanceof Date) || isNaN(seenDateUtc)) return 0.55;
    const hours = Math.max(0, (nowUtc - seenDateUtc) / 36e5);
    const halfLifeHrs = 42;
    const decay = Math.pow(0.5, hours / halfLifeHrs);
    return clamp01(0.12 + 0.88 * decay);
  }

  function tickerLiquidity(t){ return LIQ[t] ?? DEFAULT_LIQ; }
  function tickerVol(t){ return VOL[t] ?? DEFAULT_VOL; }

  function headlineTradeability01({ topicKey, title, seenDate }, nowUtc){
    const clarity = catalystClarity(title);
    const timing = timingScore(seenDate, nowUtc);

    const sectorWeights = TOPIC_SECTOR_WEIGHTS[topicKey] || {};
    const sectors = Object.keys(sectorWeights);

    let liqAvg = 0, volAvg = 0, n = 0;
    for(const s of sectors){
      const tickers = TICKER_GROUPS[s] || [];
      for(const t of tickers){
        liqAvg += tickerLiquidity(t);
        volAvg += tickerVol(t);
        n++;
      }
    }
    liqAvg = n ? (liqAvg / n) : 0.55;
    volAvg = n ? (volAvg / n) : 0.55;

    const raw = clamp01(
      0.46 * clarity +
      0.26 * timing +
      0.14 * liqAvg +
      0.14 * volAvg
    );

    return { trade01: raw, clarity, timing, liqAvg, volAvg };
  }

  function tradeabilityTo10(x01){
    return Math.max(1, Math.min(10, Math.round(x01 * 10)));
  }

  function strictConfig(strictness){
    // Linear interpolation between Idea mode and Strict mode
    const t = clamp01(strictness / 100);

    const minStrong = Math.round(0 + t * 2);          // 0..2
    const minAvg = 0.25 + t * (0.55 - 0.25);          // 0.25..0.55
    const liqFloor = 0.35 + t * (0.60 - 0.35);        // 0.35..0.60
    const etfBonus = 1.08 + t * (1.00 - 1.08);        // 1.08..1.00
    const strongCut = 6 + t * (8 - 6);                // score10 >= 6..8

    return { minStrong, minAvg, liqFloor, etfBonus, strongCut: Math.round(strongCut) };
  }

  function aggregateTickerScores(headlines, cfg){
    const tickerInfo = {};
    const tickerToGroup = {};
    for(const [g, arr] of Object.entries(TICKER_GROUPS)){
      for(const t of arr) tickerToGroup[t] = g;
    }

    function ensure(t){
      if(!tickerInfo[t]){
        const liq = tickerLiquidity(t);
        const vol = tickerVol(t);
        tickerInfo[t] = {
          ticker:t,
          group:tickerToGroup[t] || "unknown",
          liq,
          vol,
          isETF: ETF_SET.has(t),
          score:0,
          drivers:[]
        };
      }
      return tickerInfo[t];
    }

    for(const h of headlines){
      const sectorWeights = TOPIC_SECTOR_WEIGHTS[h.topicKey] || {};
      for(const [sector, w] of Object.entries(sectorWeights)){
        const tickers = TICKER_GROUPS[sector] || [];
        for(const t of tickers){
          const info = ensure(t);
          const lv = 0.55 * info.liq + 0.45 * info.vol;

          // Liquidity floor penalty (discipline)
          const liqPenalty = info.liq < cfg.liqFloor ? (info.liq / cfg.liqFloor) : 1.0;

          // ETF bonus (slight)
          const etfBoost = info.isETF ? cfg.etfBonus : 1.0;

          const add = h.trade01 * w * lv * liqPenalty * etfBoost;
          info.score += add;

          if(add > 0.03){
            info.drivers.push({
              add,
              topicKey: h.topicKey,
              title: h.title,
              url: h.url,
              seenDate: h.seenDate
            });
          }
        }
      }
    }

    const arr = Object.values(tickerInfo);
    const max = Math.max(0.0001, ...arr.map(x => x.score));
    for(const x of arr){
      x.scoreN = x.score / max;
      x.score100 = Math.round(x.scoreN * 100);
      x.drivers.sort((a,b)=>b.add-a.add);
      x.drivers = x.drivers.slice(0,4);
    }
    arr.sort((a,b)=>b.score-a.score);
    return arr;
  }

  // ========= Fetch =========
  async function fetchTopic(topic, opts, allow, matchMode){
    // Always compute query+url first so UI can show them even on error.
    const country = opts.country;
    const query = opts.customQuery?.trim()
      ? (opts.customQuery.trim() + " sourcelang:english" + (country ? ` sourcecountry:${country}` : ""))
      : buildQueryFromTerms(topic.terms, country);

    const maxrecords = Math.max(1, Math.min(250, opts.perTopic * opts.oversample));
    const url = buildGdeltUrl({ query, timespan: opts.timespan, sort: opts.sort, maxrecords });

    // Fetch
    const resp = await fetch(url, { method: "GET" });
    const text = await resp.text();

    let data;
    try { data = JSON.parse(text); }
    catch {
      // GDELT sometimes returns plain text errors with HTTP 200.
      const snip = (text || "").slice(0, 220).replace(/\s+/g, " ").trim();
      const err = `Non-JSON from GDELT (HTTP ${resp.status}): ${snip}`;
      throw Object.assign(new Error(err), { query, url, httpStatus: resp.status, bodySnippet: snip });
    }

    const articles = (data && data.articles && Array.isArray(data.articles)) ? data.articles : [];
    // Local filter by trusted domains (if enabled)
    const kept = [];
    let dropped = 0;

    for(const a of articles){
      const domain = normDomain(a.domain || "");
      if(domainAllowed(domain, allow, matchMode)){
        kept.push(a);
      }else{
        dropped++;
      }
      if(kept.length >= opts.perTopic) break;
    }

    return {
      topicKey: topic.key,
      topicLabel: topic.label,
      query,
      url,
      fetchedCount: articles.length,
      keptCount: kept.length,
      droppedCount: dropped,
      articles: kept
    };
  }

  // ========= Trade plan =========
  function addTradingDays(date, days){
    const d = new Date(date);
    let added = 0;
    while(added < days){
      d.setDate(d.getDate() + 1);
      const day = d.getDay();
      if(day !== 0 && day !== 6) added++;
    }
    return d;
  }

  function calcPlan(ticker, price, capital, feePerOrder){
    const isETF = ETF_SET.has(ticker);
    const pullback = isETF ? 0.003 : 0.007;
    const tpPct = isETF ? 0.15 : 0.22;
    const slPct = isETF ? 0.08 : 0.10;
    const timeStopDays = isETF ? 20 : 15;

    const entry = price * (1 - pullback);
    const tp = entry * (1 + tpPct);
    const sl = entry * (1 - slPct);

    const shares = Math.floor(capital / entry);
    if(shares <= 0){
      return { ok:false, msg:"Capital too small for even 1 share at the computed limit entry." };
    }

    const notional = shares * entry;
    const fees = 2 * feePerOrder; // entry + exit (TP or stop)
    const grossGain = shares * (tp - entry);
    const netGainBeforeTax = grossGain - fees;
    const tax = 0.25 * Math.max(0, netGainBeforeTax);
    const netGain = netGainBeforeTax - tax;

    const grossLoss = shares * (entry - sl);
    const netLoss = grossLoss + fees; // loss + fees
    const timeStop = addTradingDays(new Date(), timeStopDays);

    return {
      ok:true,
      isETF,
      shares,
      entry, tp, sl,
      notional,
      fees,
      tax,
      netGain,
      netGainPct: netGain / notional,
      netLoss: -netLoss,
      netLossPct: (-netLoss) / notional,
      timeStop
    };
  }

  // ========= Rendering =========
  function setActiveTab(tab){
    document.querySelectorAll(".tab").forEach(t=>{
      t.classList.toggle("active", t.dataset.tab === tab);
    });
    el.viewDecision.style.display = tab==="decision" ? "" : "none";
    el.viewHeadlines.style.display = tab==="headlines" ? "" : "none";
    el.viewTickers.style.display = tab==="tickers" ? "" : "none";
    el.viewDiag.style.display = tab==="diag" ? "" : "none";
    el.viewMethod.style.display = tab==="method" ? "" : "none";
  }

  function renderMethod(){
    el.viewMethod.innerHTML = `
      <div class="item">
        <div class="title">What this tool is doing (free-only, deterministic)</div>
        <div class="smallnote">
          1) Fetches headlines from GDELT DOC 2.0 with <span class="mono">sourcelang:english</span> locked.<br>
          2) Locally filters to a trusted domain allowlist (to avoid oversized GDELT queries that can error).<br>
          3) Scores each headline for tradability using: Catalyst Clarity + Timing + (sector) Liquidity/Volatility proxies.<br>
          4) Aggregates into per-ticker sensitivity scores using topic→sector weights and ticker liq/vol blend.<br>
          5) Makes a discipline “TRADE / NO TRADE” decision using strictness gates — while still showing top ideas transparently.
        </div>
        <div class="hr"></div>
        <div class="title">Discipline defaults (from your rules)</div>
        <div class="smallnote">
          ETFs: TP +15%, SL -8%, Time stop 15–20 trading days.<br>
          Stocks: TP +20–25% (default +22%), SL -10%, Time stop 10–15 trading days (default 15).<br>
          Limit orders only; OCO exits; one active trade at a time (execution is up to you).
        </div>
      </div>
    `;
  }

  function renderDecision(scan){
    const cfg = scan.cfg;
    const s = scan.summary;

    const decisionDot = scan.decision === "TRADE" ? "ok" : "bad";
    const decisionTitle = scan.decision === "TRADE" ? "TRADE" : "NO TRADE";

    const top = scan.topPicks || [];
    const tz = scan.opts.tz;

    const planCards = top.map((p, idx) => {
      const id = `price_${idx}`;
      const priceVal = (scan.priceInputs && scan.priceInputs[p.ticker]) ? scan.priceInputs[p.ticker] : "";
      return `
        <div class="planCard">
          <h3>${idx+1}) ${escapeHtml(p.ticker)} <span class="badge">${escapeHtml(p.group)}</span> <span class="badge">${p.isETF ? "ETF" : "Stock"}</span></h3>
          <div class="sub">
            <span class="badge"><b>Sensitivity:</b> ${p.score100}/100</span>
            <span class="badge"><b>Liq:</b> ${round2(p.liq)}</span>
            <span class="badge"><b>Vol:</b> ${round2(p.vol)}</span>
          </div>
          <label style="margin-top:10px;">Enter current price (manual)</label>
          <input data-ticker="${escapeHtml(p.ticker)}" class="priceInput" id="${id}" type="number" step="0.01" placeholder="e.g. 182.35" value="${escapeHtml(priceVal)}" />
          <div class="planOut" id="out_${idx}">Enter price to generate plan…</div>
          <div class="smallnote" style="margin-top:8px;">
            Top drivers:
            ${(p.drivers||[]).map(d => ` <a href="${escapeHtml(d.url)}" target="_blank" rel="noopener noreferrer">${escapeHtml(d.topicKey)}</a>`).join(", ") || "—"}
          </div>
        </div>
      `;
    }).join("");

    el.viewDecision.innerHTML = `
      <div class="item">
        <div class="title">
          Decision: <span class="badge"><span class="dot ${decisionDot}"></span><b>${decisionTitle}</b></span>
        </div>
        <div class="sub">
          <span class="badge"><b>Headlines (kept):</b> ${scan.countKept}</span>
          <span class="badge"><b>Strong catalysts:</b> ${s.strongCount}</span>
          <span class="badge"><b>Avg tradability:</b> ${round2(s.avgTrade01)}</span>
          <span class="badge"><b>Strictness:</b> ${scan.opts.strictness}</span>
        </div>
        <div class="smallnote" style="margin-top:10px;">
          Gates (from strictness): minStrong=${cfg.minStrong}, minAvg=${round2(cfg.minAvg)}, liqFloor=${round2(cfg.liqFloor)}, strongCut≥${cfg.strongCut}/10.
          Even if decision is NO TRADE, top ideas are still shown (transparency).
        </div>
      </div>

      <div class="item">
        <div class="title">Top 3 candidates + discipline-compliant trade plan (manual price)</div>
        <div class="smallnote">
          Enter a current price for each ticker to calculate LIMIT entry, TP/SL, time-stop, and net after fees + 25% tax (on gains only).
        </div>
        <div class="planGrid">${planCards || `<div class="smallnote">No picks (no headlines returned).</div>`}</div>
      </div>
    `;

    // Bind price inputs
    document.querySelectorAll(".priceInput").forEach(inp => {
      inp.addEventListener("input", () => {
        const t = inp.getAttribute("data-ticker");
        const price = Number(inp.value || 0);
        if(!scan.priceInputs) scan.priceInputs = {};
        scan.priceInputs[t] = inp.value;

        // recompute all outputs
        renderPlanOutputs(scan);
      });
    });

    renderPlanOutputs(scan);
  }

  function renderPlanOutputs(scan){
    const top = scan.topPicks || [];
    const capital = Math.max(1000, Math.min(2000, Number(el.capital.value || 1500)));
    const fee = Math.max(0, Number(el.fee.value || 8));
    const tz = scan.opts.tz;

    top.forEach((p, idx) => {
      const out = document.getElementById(`out_${idx}`);
      if(!out) return;

      const val = scan.priceInputs && scan.priceInputs[p.ticker] ? Number(scan.priceInputs[p.ticker]) : 0;
      if(!val || val <= 0){
        out.textContent = "Enter price to generate plan…";
        return;
      }

      const plan = calcPlan(p.ticker, val, capital, fee);
      if(!plan.ok){
        out.innerHTML = `<span style="color:var(--warn)">${escapeHtml(plan.msg)}</span>`;
        return;
      }

      const timeStopStr = fmtDate(plan.timeStop, tz);

      out.innerHTML = `
        <div class="sub">
          <span class="badge"><b>Shares:</b> ${plan.shares}</span>
          <span class="badge"><b>Notional:</b> $${Math.round(plan.notional)}</span>
          <span class="badge"><b>Fees:</b> $${Math.round(plan.fees)}</span>
          <span class="badge"><b>Tax (TP):</b> $${Math.max(0, Math.round(plan.tax))}</span>
        </div>
        <div style="margin-top:8px;">
          <div class="sub"><span class="badge"><b>LIMIT entry:</b> ${round2(plan.entry)}</span><span class="badge"><b>TP:</b> ${round2(plan.tp)}</span><span class="badge"><b>SL:</b> ${round2(plan.sl)}</span></div>
          <div class="sub" style="margin-top:6px;">
            <span class="badge"><span class="dot ok"></span><b>Net @ TP:</b> $${Math.round(plan.netGain)} (${Math.round(plan.netGainPct*1000)/10}%)</span>
            <span class="badge"><span class="dot bad"></span><b>Net @ SL:</b> $${Math.round(plan.netLoss)} (${Math.round(plan.netLossPct*1000)/10}%)</span>
          </div>
          <div class="smallnote" style="margin-top:8px;">
            OCO exits: place TP and SL; one fills cancels the other. Time stop: exit by <span class="mono">${escapeHtml(timeStopStr)}</span> if neither hit.
          </div>
        </div>
      `;
    });
  }

  function renderHeadlines(scan){
    const tz = scan.opts.tz;
    const blocks = scan.byTopic.map(t => {
      const errBlock = t.error ? `
        <div class="item" style="border-color:rgba(255,128,128,.35);">
          <div class="title">Error</div>
          <div class="smallnote">${escapeHtml(t.error)}</div>
        </div>
      ` : "";

      const items = (t.items || []).map(h => {
        const when = h.seenDate ? fmtDate(new Date(h.seenDate), tz) : "";
        const dotClass = h.score10 >= 7 ? "ok" : (h.score10 <= 3 ? "bad" : "warn");
        return `
          <div class="item">
            <div class="title">
              <a href="${escapeHtml(h.url)}" target="_blank" rel="noopener noreferrer">${escapeHtml(h.title)}</a>
            </div>
            <div class="sub">
              <span>${escapeHtml(h.domain || "")}</span>
              <span>${escapeHtml(when)}</span>
              <span class="badge"><span class="dot ${dotClass}"></span><b>Tradability:</b> ${h.score10}/10</span>
              <span class="badge"><b>Clarity:</b> ${round2(h.clarity)}</span>
              <span class="badge"><b>Timing:</b> ${round2(h.timing)}</span>
            </div>
          </div>
        `;
      }).join("");

      const openLink = t.url ? `<a href="${escapeHtml(t.url)}" target="_blank" rel="noopener noreferrer">open results</a>` : `<span class="mono">n/a</span>`;

      return `
        <div class="item">
          <div class="title">${escapeHtml(t.topicLabel)} <span class="badge">top ${t.items.length}</span></div>
          <div class="smallnote">Query: <span class="mono">${escapeHtml(t.query || "(empty)")}</span></div>
          <div class="smallnote">GDELT: ${openLink}</div>
          <div class="sub" style="margin-top:8px;">
            <span class="badge"><b>Fetched:</b> ${t.fetchedCount}</span>
            <span class="badge"><b>Trusted-kept:</b> ${t.keptCount}</span>
            <span class="badge"><b>Dropped:</b> ${t.droppedCount}</span>
          </div>
          <div style="margin-top:10px;" class="results">${errBlock}${items || `<div class="item">No trusted results for this topic.</div>`}</div>
        </div>
      `;
    }).join("");

    el.viewHeadlines.innerHTML = blocks || `<div class="item">No headlines.</div>`;
  }

  function renderTickers(scan){
    const rows = (scan.tickerTable || []).slice(0, 50).map(x => {
      return `
        <div class="item">
          <div class="title">${escapeHtml(x.ticker)} <span class="badge">${escapeHtml(x.group)}</span> <span class="badge">${x.isETF ? "ETF" : "Stock"}</span></div>
          <div class="sub">
            <span class="badge"><b>Score:</b> ${x.score100}/100</span>
            <span class="badge"><b>Liq:</b> ${round2(x.liq)}</span>
            <span class="badge"><b>Vol:</b> ${round2(x.vol)}</span>
          </div>
          ${x.drivers?.length ? `
            <div class="smallnote" style="margin-top:8px;">
              Drivers: ${x.drivers.map(d => `${escapeHtml(d.topicKey)} (+${round2(d.add)})`).join(", ")}
            </div>
          ` : `<div class="smallnote" style="margin-top:8px;">No strong drivers detected.</div>`}
        </div>
      `;
    }).join("");
    el.viewTickers.innerHTML = rows || `<div class="item">No ticker table.</div>`;
  }

  function renderDiag(scan){
    const rows = scan.byTopic.map(t => {
      const urlLen = (t.url || "").length;
      const qLen = (t.query || "").length;
      const warn = (urlLen > 1800 || qLen > 900) ? "warn" : "";
      return `
        <div class="item">
          <div class="title">${escapeHtml(t.topicLabel)} <span class="badge"><span class="dot ${warn ? "warn" : "ok"}"></span>URL len ${urlLen}</span></div>
          <div class="smallnote">Query length: <span class="mono">${qLen}</span></div>
          <div class="smallnote">URL: <span class="mono" style="word-break:break-word;">${escapeHtml(t.url || "")}</span></div>
          ${t.error ? `<div class="smallnote" style="color:var(--bad); margin-top:8px;">${escapeHtml(t.error)}</div>` : ``}
        </div>
      `;
    }).join("");

    el.viewDiag.innerHTML = `
      <div class="item">
        <div class="title">Diagnostics</div>
        <div class="smallnote">
          If you see “Failed to fetch”:
          (1) disable adblock/privacy extensions, (2) try a different network,
          or (3) proxy GDELT via a Cloudflare Worker to avoid CORS/network blocks.
          If you see “Non-JSON (HTTP 200) … query too short or too long”, your GDELT query is oversized — this build avoids that by filtering domains locally.
        </div>
      </div>
      ${rows || `<div class="item">No diagnostics.</div>`}
    `;
  }

  function renderAll(scan){
    el.meta.textContent = `Scan @ ${fmtDate(new Date(scan.createdAt), scan.opts.tz)} | headlines kept: ${scan.countKept} | decision: ${scan.decision}`;
    renderDecision(scan);
    renderHeadlines(scan);
    renderTickers(scan);
    renderDiag(scan);
    renderMethod();
  }

  // ========= History =========
  const STORAGE_KEY = "trade_advisor_history_v2";

  function loadHistory(){
    const raw = localStorage.getItem(STORAGE_KEY);
    let arr = [];
    try { arr = raw ? JSON.parse(raw) : []; } catch {}
    return Array.isArray(arr) ? arr : [];
  }

  function saveHistory(arr){
    localStorage.setItem(STORAGE_KEY, JSON.stringify(arr.slice(0, 30)));
  }

  function refreshHistoryDropdown(){
    const arr = loadHistory();
    el.history.innerHTML = "";
    const opt0 = document.createElement("option");
    opt0.value = "";
    opt0.textContent = "— Select saved scan —";
    el.history.appendChild(opt0);

    for(let i=0;i<arr.length;i++){
      const s = arr[i];
      const o = document.createElement("option");
      o.value = String(i);
      const dt = new Date(s.createdAt);
      const top = (s.topPicks || []).map(x=>x.ticker).join(", ");
      o.textContent = `${i+1}) ${dt.toLocaleString()} | Top: ${top || "—"} | ${s.decision || ""}`;
      el.history.appendChild(o);
    }
  }

  // ========= Main run =========
  async function runScan(){
    setStatus("");
    el.runBtn.disabled = true;
    el.saveBtn.disabled = true;
    el.exportBtn.disabled = true;

    const nowUtc = new Date();
    const strictness = Math.max(0, Math.min(100, Number(el.strictness.value || 45)));
    const cfg = strictConfig(strictness);

    const opts = {
      timespan: el.timespan.value,
      sort: el.sort.value,
      perTopic: Math.max(1, Math.min(25, Number(el.perTopic.value || 5))),
      oversample: Math.max(2, Math.min(10, Number(el.oversample.value || 4))),
      concurrency: Math.max(1, Math.min(10, Number(el.concurrency.value || 4))),
      tz: el.tz.value || "Asia/Jerusalem",
      country: el.country.value.trim(),
      customQuery: el.customQuery.value,
      strictness
    };

    const mode =
      strictness < 25 ? "Idea Mode" :
      strictness < 60 ? "Balanced" : "Strict";
    el.modePill.textContent = `Mode: ${mode}`;

    const allow = getAllowlist();
    const matchMode = el.domainMatch.value;

    setPills([
      ["timespan", opts.timespan],
      ["sort", opts.sort || "relevance"],
      ["perTopic", opts.perTopic],
      ["oversample", "x" + opts.oversample],
      ["concurrency", opts.concurrency],
      ["country", opts.country || "—"],
      ["allowlist", allow.length ? `${allow.length} domains` : "off"]
    ]);

    setStatus("Fetching headlines from GDELT…");

    let byTopicRaw;
    try{
      byTopicRaw = await mapLimit(TOPICS, opts.concurrency, async (topic) => {
        try{
          const r = await fetchTopic(topic, opts, allow, matchMode);
          return { ...r, error: null };
        }catch(e){
          // Preserve query+url if present on the thrown error object
          const q = e.query || "";
          const u = e.url || "";
          const err = String(e.message || e);
          return {
            topicKey: topic.key,
            topicLabel: topic.label,
            query: q,
            url: u,
            fetchedCount: 0,
            keptCount: 0,
            droppedCount: 0,
            articles: [],
            error: err
          };
        }
      });
    }catch(e){
      setStatus(String(e.message || e), "error");
      el.runBtn.disabled = false;
      return;
    }

    // Normalize & score headlines
    const keptHeadlines = [];
    const byTopic = byTopicRaw.map(t => {
      const items = (t.articles || []).map(a => {
        const title = a.title || "(no title)";
        const url = a.url || a.url_mobile || "#";
        const domain = a.domain || "";
        const seenDate = parseGdeltSeenDate(a.seendate || a.seenDate || "");

        const { trade01, clarity, timing } = headlineTradeability01({
          topicKey: t.topicKey, title, seenDate
        }, nowUtc);

        const score10 = tradeabilityTo10(trade01);

        const h = {
          topicKey: t.topicKey,
          topicLabel: t.topicLabel,
          title, url, domain,
          seenDate: seenDate ? seenDate.toISOString() : null,
          trade01,
          score10,
          clarity, timing
        };
        keptHeadlines.push(h);
        return h;
      });

      return {
        topicKey: t.topicKey,
        topicLabel: t.topicLabel,
        query: t.query,
        url: t.url,
        error: t.error,
        fetchedCount: t.fetchedCount || 0,
        keptCount: t.keptCount || items.length || 0,
        droppedCount: t.droppedCount || 0,
        items
      };
    });

    // Summary for discipline gates
    const strongCount = keptHeadlines.filter(h => h.score10 >= cfg.strongCut).length;
    const avgTrade01 = keptHeadlines.length ? (keptHeadlines.reduce((s,h)=>s+h.trade01,0) / keptHeadlines.length) : 0;

    const summary = { strongCount, avgTrade01 };

    // Aggregate to tickers
    const tickerTable = aggregateTickerScores(keptHeadlines, cfg);
    const topPicks = tickerTable.slice(0,3);

    // Decision (discipline gates)
    const decision =
      (strongCount >= cfg.minStrong && avgTrade01 >= cfg.minAvg && keptHeadlines.length > 0)
      ? "TRADE" : "NO TRADE";

    const scan = {
      createdAt: nowUtc.toISOString(),
      opts,
      cfg,
      byTopic,
      countKept: keptHeadlines.length,
      summary,
      tickerTable,
      topPicks,
      decision,
      priceInputs: {} // manual price cache per scan
    };

    lastScan = scan;

    if(keptHeadlines.length === 0){
      const hasErrors = byTopic.some(x=>x.error);
      setStatus(hasErrors ? "0 headlines kept. Some topics errored — see Diagnostics/Headlines tabs." : "0 headlines kept. Try broader preset, broader domain matching, or longer lookback.", "warn");
    }else{
      const errCount = byTopic.filter(x=>x.error).length;
      setStatus(errCount ? `Completed with ${errCount} topic errors (see Diagnostics).` : "Completed.");
    }

    renderAll(scan);
    el.runBtn.disabled = false;
    el.saveBtn.disabled = false;
    el.exportBtn.disabled = false;
  }

  // ========= Save / Export / Clear =========
  function saveCurrent(){
    if(!lastScan) return;
    const arr = loadHistory();
    arr.unshift(lastScan);
    saveHistory(arr);
    refreshHistoryDropdown();
    setStatus("Saved to History.");
  }

  function exportJson(){
    if(!lastScan) return;
    const blob = new Blob([JSON.stringify(lastScan, null, 2)], { type:"application/json" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = `scan_${new Date(lastScan.createdAt).toISOString().replaceAll(":","-")}.json`;
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  }

  function clearHistory(){
    localStorage.removeItem(STORAGE_KEY);
    refreshHistoryDropdown();
    setStatus("History cleared.");
  }

  function loadFromHistoryIndex(idx){
    const arr = loadHistory();
    const scan = arr[idx];
    if(!scan) return;
    lastScan = scan;
    setStatus("Loaded saved scan (no re-fetch).");
    renderAll(scan);
    el.saveBtn.disabled = false;
    el.exportBtn.disabled = false;
  }

  // ========= Allowlist storage =========
  const LIST_KEY = "trade_advisor_allowlist_v1";

  function setAllowlistFromPreset(){
    const p = el.preset.value;
    const lines = (p === "off") ? [] : (PRESETS[p] || PRESETS.expanded);
    el.allowlist.value = lines.join("\n");
  }

  function saveAllowlist(){
    const payload = {
      preset: el.preset.value,
      match: el.domainMatch.value,
      text: el.allowlist.value
    };
    localStorage.setItem(LIST_KEY, JSON.stringify(payload));
    setStatus("Trusted list saved.");
  }

  function loadAllowlist(){
    try{
      const raw = localStorage.getItem(LIST_KEY);
      if(!raw) return false;
      const j = JSON.parse(raw);
      if(j.preset) el.preset.value = j.preset;
      if(j.match) el.domainMatch.value = j.match;
      if(typeof j.text === "string") el.allowlist.value = j.text;
      return true;
    }catch{
      return false;
    }
  }

  // ========= Tabs =========
  document.querySelectorAll(".tab").forEach(t=>{
    t.addEventListener("click", () => setActiveTab(t.dataset.tab));
  });

  // ========= Strictness sync =========
  function syncStrictness(from){
    const v = Math.max(0, Math.min(100, Number(from.value || 0)));
    el.strictness.value = String(v);
    el.strictnessNum.value = String(v);
    const mode =
      v < 25 ? "Idea Mode" :
      v < 60 ? "Balanced" : "Strict";
    el.modePill.textContent = `Mode: ${mode}`;
  }
  el.strictness.addEventListener("input", () => syncStrictness(el.strictness));
  el.strictnessNum.addEventListener("input", () => syncStrictness(el.strictnessNum));

  // ========= Buttons =========
  el.runBtn.addEventListener("click", runScan);
  el.saveBtn.addEventListener("click", saveCurrent);
  el.exportBtn.addEventListener("click", exportJson);
  el.clearHistoryBtn.addEventListener("click", clearHistory);

  el.resetListBtn.addEventListener("click", () => {
    setAllowlistFromPreset();
    setStatus("Allowlist reset to preset.");
  });
  el.saveListBtn.addEventListener("click", saveAllowlist);

  el.preset.addEventListener("change", () => setAllowlistFromPreset());

  el.history.addEventListener("change", () => {
    const v = el.history.value;
    if(!v) return;
    loadFromHistoryIndex(Number(v));
  });

  // ========= Init =========
  refreshHistoryDropdown();
  setActiveTab("decision");
  syncStrictness(el.strictness);

  // load allowlist settings, otherwise seed from preset
  const loaded = loadAllowlist();
  if(!loaded) setAllowlistFromPreset();
  renderMethod();
})();
</script>
</body>
</html>
