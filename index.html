<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Event-Driven Trade Advisor (Trusted English GDELT)</title>
  <style>
    :root{
      --bg:#0b0f17; --panel:#0e162a; --panel2:#0b1020;
      --border:#1d2a44; --border2:#233357;
      --text:#e8eefc; --muted:rgba(232,238,252,.72);
      --accent:#2a5cff; --bad:#ff8080; --ok:#93ffb4; --warn:#ffd27a;
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
    }
    body{margin:0;background:var(--bg);color:var(--text);}
    header{padding:18px 18px;border-bottom:1px solid var(--border);background:#0b1020;}
    header h1{margin:0 0 6px;font-size:18px;}
    header p{margin:0;color:var(--muted);font-size:13px;line-height:1.35;}
    main{padding:16px 18px;max-width:1200px;margin:0 auto;}
    .grid{display:grid;grid-template-columns:1fr;gap:12px;}
    @media(min-width:980px){.grid{grid-template-columns:440px 1fr;}}
    .card{background:var(--panel);border:1px solid var(--border);border-radius:14px;padding:14px;}
    label{display:block;font-size:12px;color:var(--muted);margin:10px 0 6px;}
    input,select,textarea,button{
      width:100%;box-sizing:border-box;border-radius:12px;border:1px solid var(--border2);
      background:var(--panel2);color:var(--text);padding:10px 11px;font-size:14px;
    }
    textarea{min-height:66px;resize:vertical;}
    .row{display:grid;grid-template-columns:1fr 1fr;gap:10px;}
    .row3{display:grid;grid-template-columns:1fr 1fr 1fr;gap:10px;}
    .actions{display:grid;grid-template-columns:1fr 1fr;gap:10px;margin-top:12px;}
    button{cursor:pointer;font-weight:800;}
    button.primary{background:var(--accent);border-color:var(--accent);}
    button.ghost{background:transparent;}
    button:disabled{opacity:.65;cursor:not-allowed;}
    .status{margin-top:10px;font-size:13px;color:var(--muted);}
    .status.error{color:var(--bad);}
    .pillbar{display:flex;flex-wrap:wrap;gap:8px;margin-top:10px;}
    .pill{border:1px solid var(--border2);background:var(--panel2);padding:5px 9px;border-radius:999px;font-size:12px;color:var(--muted);}
    .rightHead{display:flex;align-items:flex-end;justify-content:space-between;gap:12px;margin-bottom:10px;}
    .rightHead h2{margin:0;font-size:16px;}
    .rightHead .small{font-size:12px;color:var(--muted);text-align:right;}
    .tabs{display:flex;gap:8px;flex-wrap:wrap;margin:0 0 10px;}
    .tab{padding:8px 10px;border-radius:999px;border:1px solid var(--border2);background:var(--panel2);font-size:12px;color:var(--muted);cursor:pointer;user-select:none;}
    .tab.active{border-color:var(--accent);color:var(--text);}
    .results{display:grid;gap:10px;}
    .item{border-radius:14px;border:1px solid var(--border);background:var(--panel2);padding:12px;}
    .item .title{margin:0 0 6px;font-weight:900;line-height:1.25;}
    .item a{color:#9dc0ff;text-decoration:none;}
    .item a:hover{text-decoration:underline;}
    .sub{display:flex;gap:10px;flex-wrap:wrap;font-size:12px;color:var(--muted);align-items:center;}
    .scoreline{display:flex;gap:10px;flex-wrap:wrap;margin-top:8px;font-size:12px;color:var(--muted);}
    .badge{display:inline-flex;align-items:center;gap:6px;border:1px solid var(--border2);background:#0b1020;padding:4px 8px;border-radius:999px;}
    .dot{width:8px;height:8px;border-radius:999px;background:var(--muted);display:inline-block;}
    .dot.ok{background:var(--ok);}
    .dot.bad{background:var(--bad);}
    .dot.warn{background:var(--warn);}
    .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace;}
    .smallnote{font-size:12px;color:var(--muted);line-height:1.35;margin-top:10px;}
    .hr{height:1px;background:var(--border);margin:10px 0;}
    .tight{margin-top:6px;}
    .kpi{display:grid;grid-template-columns:1fr 1fr;gap:10px;margin-top:8px;}
    .kpi .box{border:1px solid var(--border);background:#0b1020;border-radius:12px;padding:10px;}
    .kpi .box b{display:block;font-size:12px;margin-bottom:3px;}
    .kpi .box span{color:var(--muted);font-size:12px;}
    .bar{height:10px;border-radius:999px;background:#0b1020;border:1px solid var(--border2);overflow:hidden;}
    .bar > div{height:100%;background:var(--accent);width:0%;}
    .warnbox{border:1px solid rgba(255,210,122,.35);background:rgba(255,210,122,.07);}
    .okbox{border:1px solid rgba(147,255,180,.35);background:rgba(147,255,180,.07);}
    .badbox{border:1px solid rgba(255,128,128,.35);background:rgba(255,128,128,.07);}
  </style>
</head>

<body>
<header>
  <h1>Event-Driven Trade Advisor <span class="badge"><span class="dot ok"></span>v6 Trusted English</span></h1>
  <p>
    Pulls the latest headlines from GDELT DOC 2.0 (English-only + trusted-domain allowlist), scores tradability, and produces a compliant trade plan
    using manual entry price (no paid market-data required). Research tool only, not investment advice.
  </p>
</header>

<main class="grid">
  <!-- LEFT: Controls -->
  <section class="card">
    <div class="row">
      <div>
        <label>Lookback (TIMESPAN)</label>
        <select id="timespan">
          <option value="1h">Last 1 hour</option>
          <option value="6h">Last 6 hours</option>
          <option value="12h" selected>Last 12 hours</option>
          <option value="1day">Last 1 day</option>
          <option value="3day">Last 3 days</option>
          <option value="1week">Last 1 week</option>
        </select>
      </div>
      <div>
        <label>Sort</label>
        <select id="sort">
          <option value="datedesc" selected>Date (newest first)</option>
          <option value="">Relevance</option>
          <option value="toneasc">Tone (most negative)</option>
          <option value="tonedesc">Tone (most positive)</option>
        </select>
      </div>
    </div>

    <div class="row3">
      <div>
        <label>Headlines / topic</label>
        <input id="perTopic" type="number" min="1" max="25" value="5" />
      </div>
      <div>
        <label>Concurrency</label>
        <input id="concurrency" type="number" min="1" max="10" value="4" />
      </div>
      <div>
        <label>Time zone display</label>
        <select id="tz">
          <option value="Asia/Jerusalem" selected>Asia/Jerusalem</option>
          <option value="UTC">UTC</option>
          <option value="America/New_York">America/New_York</option>
          <option value="Europe/London">Europe/London</option>
        </select>
      </div>
    </div>

    <label>Strictness (0 = Idea Mode, 100 = Strict)</label>
    <input id="strictness" type="range" min="0" max="100" value="70" />
    <div class="sub tight">
      <span class="badge"><span class="dot warn"></span><b>Mode:</b> <span id="modeLabel">Strict</span></span>
      <span class="badge"><b>English:</b> <span class="mono">sourcelang:english</span> (locked)</span>
    </div>

    <label>Optional filter (applied to all topics)</label>
    <input id="country" placeholder="sourcecountry (e.g. unitedstates)" />

    <label>Trusted domains allowlist (ENFORCED)</label>
    <textarea id="trustedDomains"></textarea>
    <div class="row">
      <button id="resetDomainsBtn" class="ghost">Reset Trusted List</button>
      <button id="saveDomainsBtn" class="ghost">Save List</button>
    </div>
    <div class="smallnote">
      Only articles whose domain matches this allowlist are fetched. This increases signal quality but can reduce coverage.
      If you get frequent NO TRADE, increase lookback (e.g., 12h → 1day).
    </div>

    <label>Optional: custom topic query override (advanced)</label>
    <textarea id="customQuery" placeholder='Leave blank. Example: ("export controls" OR sanctions)'></textarea>
    <div class="smallnote">
      Even with a custom query, the app will still enforce: <span class="mono">sourcelang:english</span> AND trusted-domain allowlist.
    </div>

    <div class="actions">
      <button id="runBtn" class="primary">Run Scan</button>
      <button id="saveBtn" class="ghost" disabled>Save to History</button>
    </div>

    <div class="actions" style="grid-template-columns:1fr 1fr;">
      <button id="exportBtn" class="ghost" disabled>Export JSON</button>
      <button id="clearHistoryBtn" class="ghost">Clear History</button>
    </div>

    <div id="status" class="status"></div>
    <div id="pills" class="pillbar"></div>

    <div class="hr"></div>

    <label>Trade plan inputs (manual)</label>
    <div class="row">
      <div>
        <label>Capital per trade (USD)</label>
        <input id="capital" type="number" min="1000" max="2000" value="1500" />
      </div>
      <div>
        <label>Stock TP % (20–25)</label>
        <input id="stockTp" type="number" min="20" max="25" value="22" />
      </div>
    </div>

    <div class="smallnote">
      Fees: $8 per executed order. Tax: 25% on net gains. One active trade at a time (policy), not enforced by code.
    </div>

    <div class="hr"></div>

    <label>History (localStorage)</label>
    <select id="history"></select>
    <div class="smallnote">Select a past scan to re-load its results without re-fetching news.</div>
  </section>

  <!-- RIGHT: Results -->
  <section class="card">
    <div class="rightHead">
      <h2>Results</h2>
      <div id="meta" class="small"></div>
    </div>

    <div class="tabs">
      <div class="tab active" data-tab="decision">Trade Decision</div>
      <div class="tab" data-tab="headlines">Headlines by Topic</div>
      <div class="tab" data-tab="tickers">Ticker Table</div>
      <div class="tab" data-tab="diagnostics">Diagnostics</div>
      <div class="tab" data-tab="method">Scoring Method</div>
    </div>

    <div id="viewDecision" class="results"></div>
    <div id="viewHeadlines" class="results" style="display:none;"></div>
    <div id="viewTickers" class="results" style="display:none;"></div>
    <div id="viewDiagnostics" class="results" style="display:none;"></div>
    <div id="viewMethod" class="results" style="display:none;"></div>
  </section>
</main>

<script>
(() => {
  // ---------- Constants ----------
  const VERSION = "v6-trusted-english-discipline";
  const GDELT_ENDPOINT = "https://api.gdeltproject.org/api/v2/doc/doc";
  const LOCKED_SOURCELANG = "english";

  // Trusted domains (editable, but always enforced)
  const TRUSTED_DOMAINS_DEFAULT = [
    "reuters.com","apnews.com","bloomberg.com","ft.com","wsj.com","economist.com",
    "bbc.co.uk","theguardian.com","nytimes.com","washingtonpost.com","cnbc.com",
    "federalreserve.gov","ecb.europa.eu","bankofengland.co.uk","bls.gov","bea.gov",
    "opec.org","usgs.gov","noaa.gov"
  ];

  // User-provided universe
  const TICKER_GROUPS = {
    defense: ["PPA","ITA","LMT","NOC","GD","RTX","BA","HII","LHX","TDG","AVAV","KTOS"],
    cyber: ["CIBR","HACK","PANW","CRWD","FTNT","ZS","OKTA","NET"],
    semis: ["SMH","SOXX","NVDA","AVGO","TSM","MU","ASML","AMAT","LRCX","KLAC","AMD","ARM","MRVL"],
    energy: ["XLE","XOP","LNG","VLO","CVX","XOM","SLB","HAL","OIH"],
    shipping: ["INSW","STNG","TK","ZIM","DAC"],
    uranium: ["URNM","URA","CCJ","UEC","LEU"],
    water_agri: ["PHO","MOO","DBA","NTR","MOS","CF","DE"],
    insurers: ["KIE","CB","TRV","ALL","AIG"],
    gold: ["GLD","IAU","GDX"]
  };

  // ETF set (for rule differences: pullback, TP/SL, time stop)
  const ETF_SET = new Set([
    "PPA","ITA","CIBR","HACK","SMH","SOXX","XLE","XOP","OIH","KIE","URNM","URA","PHO","MOO","DBA","GLD","IAU","GDX"
  ]);

  // Topics requested (bundled)
  const TOPICS = [
    { key:"geopolitics", label:"geopolitics", terms:['geopolitics','"regional tensions"','"border clash"','"military buildup"','"diplomatic crisis"'] },
    { key:"sanctions", label:"sanctions", terms:['sanctions','"export controls"','"blacklist"','"secondary sanctions"','"asset freeze"'] },
    { key:"ceasefire", label:"ceasefire", terms:['ceasefire','truce','"peace talks"','"temporary halt"'] },
    { key:"war", label:"war", terms:['war','airstrike','"missile attack"','"ground offensive"','"troop deployment"'] },
    { key:"regulation", label:"regulation", terms:['regulation','"regulatory crackdown"','antitrust','"compliance rule"','SEC','FTC'] },
    { key:"tariff", label:"tariff", terms:['tariff','"trade war"','"import duty"','"export ban"'] },
    { key:"cyber", label:"cyber", terms:['cyber','ransomware','"data breach"','DDoS','"zero-day"','hackers'] },
    { key:"earthquake", label:"earthquake", terms:['earthquake','seismic','aftershock','magnitude'] },
    { key:"flood", label:"flood", terms:['flood','"flash flood"','"storm surge"','"river overflow"'] },
    { key:"wildfire", label:"wildfire", terms:['wildfire','"forest fire"','"evacuation order"','burning'] },
    { key:"inflation", label:"inflation", terms:['inflation','CPI','PCE','"price pressures"','"core inflation"'] },
    { key:"rates", label:"rates", terms:['"interest rate"','"rate hike"','"rate cut"','"policy rate"','"Federal Reserve"','ECB','BoE'] },
    { key:"recession", label:"recession", terms:['recession','"GDP contraction"','"yield curve"','"job losses"','"hard landing"'] },
    { key:"OPEC", label:"OPEC", terms:['OPEC','"OPEC+"','"oil output"','"production cut"','quota'] },
    { key:"oil", label:"oil", terms:['"crude oil"','Brent','WTI','"oil prices"','"oil supply"'] }
  ];

  // Topic -> sector weights (0..1). Directional “beneficiary bias” for long-only.
  const TOPIC_SECTOR_WEIGHTS = {
    geopolitics: { defense:0.8, energy:0.6, shipping:0.5, gold:0.6, insurers:0.2 },
    sanctions:   { energy:0.5, shipping:0.5, defense:0.4, semis:0.25, gold:0.3 },
    ceasefire:   { shipping:0.6, energy:0.25, gold:0.15, defense:0.15 },
    war:         { defense:0.9, energy:0.6, gold:0.7, shipping:0.4 },
    regulation:  { insurers:0.35, semis:0.25, energy:0.2 },
    tariff:      { semis:0.45, shipping:0.35, energy:0.2 },
    cyber:       { cyber:0.95 },
    earthquake:  { insurers:0.25, water_agri:0.25, energy:0.15 },
    flood:       { insurers:0.25, water_agri:0.35, energy:0.15 },
    wildfire:    { insurers:0.25, water_agri:0.35, energy:0.15 },
    inflation:   { gold:0.35, insurers:0.25, energy:0.2 },
    rates:       { insurers:0.35, gold:0.25 },
    recession:   { gold:0.45, insurers:0.25 },
    OPEC:        { energy:0.9, shipping:0.35 },
    oil:         { energy:0.85, shipping:0.3 }
  };

  // Heuristic Liquidity scores (0..1). Edit freely.
  const LIQ = Object.fromEntries([
    ["PPA",0.75],["ITA",0.8],["CIBR",0.8],["HACK",0.7],["SMH",0.85],["SOXX",0.85],
    ["XLE",0.9],["XOP",0.75],["OIH",0.6],["KIE",0.65],["URNM",0.55],["URA",0.65],
    ["PHO",0.55],["MOO",0.55],["DBA",0.6],["GLD",0.95],["IAU",0.85],["GDX",0.75],
    ["NVDA",0.95],["AVGO",0.9],["TSM",0.9],["AMD",0.9],["XOM",0.9],["CVX",0.85],
    ["BA",0.85],["RTX",0.8],["LMT",0.75],["PANW",0.8],["CRWD",0.8],["NET",0.75],
    ["AVAV",0.55],["KTOS",0.5],["HII",0.45],["INSW",0.45],["STNG",0.5],["TK",0.4],
    ["ZIM",0.6],["DAC",0.45],["UEC",0.45],["LEU",0.45]
  ]);

  // Heuristic Volatility scores (0..1). Edit freely.
  const VOL = Object.fromEntries([
    ["NVDA",0.9],["AMD",0.85],["ARM",0.85],["MRVL",0.8],["MU",0.85],
    ["XOP",0.8],["OIH",0.85],["HAL",0.75],["SLB",0.7],
    ["ZIM",0.9],["STNG",0.75],["INSW",0.6],
    ["CRWD",0.8],["PANW",0.65],["NET",0.75],["FTNT",0.65],
    ["GLD",0.35],["GDX",0.6],["IAU",0.3],
    ["LMT",0.35],["NOC",0.35],["RTX",0.4],["BA",0.6],["KTOS",0.7],["AVAV",0.65],
    ["KIE",0.35],["AIG",0.45],["ALL",0.35]
  ]);

  const DEFAULT_LIQ = 0.55;
  const DEFAULT_VOL = 0.55;

  // Runtime gate settings (derived from strictness)
  const RUNTIME = {
    strictness: 0.70,      // 0..1
    ideaMode: false,
    minAvgTrade01: 0.40,   // 0..1
    minKept: 8,
    strongScoreCut: 6,
    strongClarityCut: 0.45,
    requireStrong: true
  };

  // ---------- UI ----------
  const el = {
    timespan: document.getElementById("timespan"),
    sort: document.getElementById("sort"),
    perTopic: document.getElementById("perTopic"),
    concurrency: document.getElementById("concurrency"),
    tz: document.getElementById("tz"),
    strictness: document.getElementById("strictness"),
    modeLabel: document.getElementById("modeLabel"),
    country: document.getElementById("country"),
    trustedDomains: document.getElementById("trustedDomains"),
    resetDomainsBtn: document.getElementById("resetDomainsBtn"),
    saveDomainsBtn: document.getElementById("saveDomainsBtn"),
    customQuery: document.getElementById("customQuery"),
    capital: document.getElementById("capital"),
    stockTp: document.getElementById("stockTp"),
    runBtn: document.getElementById("runBtn"),
    saveBtn: document.getElementById("saveBtn"),
    exportBtn: document.getElementById("exportBtn"),
    clearHistoryBtn: document.getElementById("clearHistoryBtn"),
    status: document.getElementById("status"),
    pills: document.getElementById("pills"),
    meta: document.getElementById("meta"),
    history: document.getElementById("history"),
    viewDecision: document.getElementById("viewDecision"),
    viewHeadlines: document.getElementById("viewHeadlines"),
    viewTickers: document.getElementById("viewTickers"),
    viewDiagnostics: document.getElementById("viewDiagnostics"),
    viewMethod: document.getElementById("viewMethod"),
  };

  let lastScan = null;

  // ---------- Helpers ----------
  const clamp01 = (x) => Math.max(0, Math.min(1, x));
  const round2 = (x) => Math.round(x * 100) / 100;
  const round4 = (x) => Math.round(x * 10000) / 10000;

  function setStatus(msg, isError=false){
    el.status.textContent = msg || "";
    el.status.className = "status" + (isError ? " error" : "");
  }

  function setPills(pairs){
    el.pills.innerHTML = "";
    for(const [k,v] of pairs){
      const d = document.createElement("div");
      d.className = "pill";
      d.textContent = `${k}: ${v}`;
      el.pills.appendChild(d);
    }
  }

  function escapeHtml(s){
    return String(s ?? "")
      .replaceAll("&","&amp;").replaceAll("<","&lt;").replaceAll(">","&gt;")
      .replaceAll('"',"&quot;").replaceAll("'","&#039;");
  }

  function fmtDate(dt, tz){
    try{
      return new Intl.DateTimeFormat(undefined, {
        timeZone: tz, year:"numeric", month:"2-digit", day:"2-digit",
        hour:"2-digit", minute:"2-digit", second:"2-digit"
      }).format(dt);
    }catch{
      return dt.toISOString();
    }
  }

  function parseDomains(text){
    const raw = String(text || "");
    return raw
      .split(/[\n,;\s]+/g)
      .map(x => x.trim().toLowerCase())
      .filter(Boolean)
      .filter(x => x.includes("."));
  }

  function domainAllowlistClause(domains){
    if(!domains || !domains.length) return "";
    // Use domainis: to avoid suffix collisions (e.g., un.org vs catholicsun.org)
    const parts = domains.map(d => `domainis:${d}`);
    return "(" + parts.join(" OR ") + ")";
  }

  // ---------- Strictness mapping ----------
  function applyStrictnessFromUI(){
    const sPct = Math.max(0, Math.min(100, Number(el.strictness.value || 70)));
    const s = sPct / 100;

    RUNTIME.strictness = s;

    // Idea mode: always show best sensitivity picks if there is data
    RUNTIME.ideaMode = (s <= 0.05);

    // Gates tuned for "trusted-only" input (fewer headlines). Higher strictness still yields NO TRADE often.
    RUNTIME.minAvgTrade01 = RUNTIME.ideaMode ? 0 : (0.18 + s * (0.45 - 0.18)); // 0.18..0.45
    RUNTIME.minKept = RUNTIME.ideaMode ? 1 : Math.round(6 + s * 10);           // 6..16
    RUNTIME.strongScoreCut   = RUNTIME.ideaMode ? 4 : (s >= 0.70 ? 6 : (s >= 0.45 ? 5 : 4));
    RUNTIME.strongClarityCut = RUNTIME.ideaMode ? 0.30 : (s >= 0.70 ? 0.45 : (s >= 0.45 ? 0.38 : 0.30));
    RUNTIME.requireStrong = !RUNTIME.ideaMode && (s >= 0.40);

    el.modeLabel.textContent = RUNTIME.ideaMode ? "Idea Mode" : (s >= 0.75 ? "Strict" : (s >= 0.45 ? "Balanced" : "Lenient"));
  }

  // ---------- Scoring ----------
  function tickerLiquidity(t){ return LIQ[t] ?? DEFAULT_LIQ; }
  function tickerVol(t){ return VOL[t] ?? DEFAULT_VOL; }

  // Catalyst clarity: “specific / actionable / market relevant” proxy from title.
  function catalystClarity(title){
    const t = (title || "").toLowerCase();
    let score = 0.18;

    const hasNumber = /(\d+(\.\d+)?)|(%|\$|bps|basis points|million|billion|mbpd)/i.test(title || "");
    if(hasNumber) score += 0.18;

    const actionVerbs = [
      "announces","imposes","approves","ban","bans","halts","suspends","launches","strikes","attacks",
      "cuts","raises","hikes","slashes","warns","sanctions","tariff","export controls","ceasefire",
      "breach","ransomware","hack","exploit","zero-day","evacuation","earthquake","flood","wildfire"
    ];
    for(const w of actionVerbs){
      if(t.includes(w)) score += 0.03;
    }

    const specificityHints = ["opec","fed","ecb","boe","cpi","pce","brent","wti","pipeline","shipping lane","red sea","strait","export controls","tariffs"];
    for(const w of specificityHints){
      if(t.includes(w)) score += 0.05;
    }

    const soft = ["what you need to know","explainer","analysis","opinion","why it matters","live updates","timeline","explained"];
    for(const w of soft){
      if(t.includes(w)) score -= 0.05;
    }

    return clamp01(score);
  }

  function isSoftHeadline(title){
    const t = (title || "").toLowerCase();
    const soft = ["what you need to know","explainer","analysis","opinion","why it matters","live updates","timeline","explained"];
    return soft.some(w => t.includes(w));
  }

  // Timing: prioritize recency, tuned for 15–20 day swings (half-life slower than day-trading).
  function timingScore(seenDateUtc, nowUtc){
    if(!seenDateUtc || !(seenDateUtc instanceof Date) || isNaN(seenDateUtc)) return 0.55;
    const hours = Math.max(0, (nowUtc - seenDateUtc) / 36e5);
    const halfLifeHrs = 48;
    const score = Math.pow(0.5, hours / halfLifeHrs);
    return clamp01(0.15 + 0.85 * score);
  }

  // Headline -> 1..10 impact
  function headlineImpactScore({ topicKey, title, seenDate }, nowUtc){
    const clarity = catalystClarity(title);
    const timing = timingScore(seenDate, nowUtc);

    const sectorWeights = TOPIC_SECTOR_WEIGHTS[topicKey] || {};
    const sectors = Object.keys(sectorWeights);

    let liqAvg = 0, volAvg = 0, n = 0;
    for(const s of sectors){
      const tickers = TICKER_GROUPS[s] || [];
      for(const t of tickers){
        liqAvg += tickerLiquidity(t);
        volAvg += tickerVol(t);
        n++;
      }
    }
    liqAvg = n ? (liqAvg / n) : 0.55;
    volAvg = n ? (volAvg / n) : 0.55;

    const raw = clamp01(
      0.45 * clarity +
      0.25 * timing +
      0.15 * liqAvg +
      0.15 * volAvg
    );

    const score10 = Math.max(1, Math.min(10, Math.round(raw * 10)));
    return { score10, clarity, timing, liqAvg, volAvg };
  }

  // Aggregate to tickers and also compute group contributions for diagnostics
  function aggregateTickerScores(headlines){
    const tickerInfo = {};
    const tickerToGroup = {};
    for(const [g, arr] of Object.entries(TICKER_GROUPS)){
      for(const t of arr) tickerToGroup[t] = g;
    }

    const groupContrib = Object.fromEntries(Object.keys(TICKER_GROUPS).map(g => [g, 0]));

    function ensure(t){
      if(!tickerInfo[t]){
        tickerInfo[t] = {
          ticker:t,
          group:tickerToGroup[t] || "unknown",
          liq:tickerLiquidity(t),
          vol:tickerVol(t),
          score:0,
          drivers:[],
          breakdownByTopic: {}
        };
      }
      return tickerInfo[t];
    }

    for(const h of headlines){
      const sectorWeights = TOPIC_SECTOR_WEIGHTS[h.topicKey] || {};
      const base = h.trade01; // 0..1
      for(const [sector, w] of Object.entries(sectorWeights)){
        const tickers = TICKER_GROUPS[sector] || [];
        for(const t of tickers){
          const info = ensure(t);
          const lv = 0.55 * info.liq + 0.45 * info.vol;
          const add = base * w * lv;
          info.score += add;

          info.breakdownByTopic[h.topicKey] = (info.breakdownByTopic[h.topicKey] || 0) + add;

          if(add > 0.030){
            info.drivers.push({
              add,
              topicKey: h.topicKey,
              title: h.title,
              url: h.url,
              seenDate: h.seenDate
            });
          }

          // group contribution (only positive adds, since long-only beneficiary bias)
          groupContrib[sector] = (groupContrib[sector] || 0) + Math.max(0, add);
        }
      }
    }

    const arr = Object.values(tickerInfo);
    const max = Math.max(0.000001, ...arr.map(x => x.score));
    for(const x of arr){
      x.scoreN = x.score / max;
      x.score100 = Math.round(x.scoreN * 100);
      x.drivers.sort((a,b)=>b.add-a.add);
      x.drivers = x.drivers.slice(0,4);
    }
    arr.sort((a,b)=>b.score-a.score);

    // normalize group contributions into shares
    const totalGroup = Object.values(groupContrib).reduce((a,b)=>a+b, 0.000001);
    const groupShares = Object.entries(groupContrib)
      .map(([g,v]) => ({ group:g, value:v, share:v/totalGroup }))
      .sort((a,b)=>b.value-a.value);

    return { tickerTable: arr, groupShares };
  }

  // ---------- Fetch ----------
  function parseGdeltSeenDate(s){
    if(!s) return null;
    const iso = String(s).replace(" ", "T") + "Z";
    const d = new Date(iso);
    return isNaN(d) ? null : d;
  }

  function buildQueryFromTerms(terms, country, trustedDomains){
    const core = "(" + terms.join(" OR ") + ")";
    let q = core;

    // Enforce English + allowlist
    q += ` sourcelang:${LOCKED_SOURCELANG}`;

    if(country) q += ` sourcecountry:${country}`;

    const allow = domainAllowlistClause(trustedDomains);
    if(allow) q += ` ${allow}`;

    return q.trim();
  }

  function buildQueryFromCustom(custom, country, trustedDomains){
    const core = "(" + custom.trim() + ")";
    let q = core;

    // Enforce English + allowlist
    q += ` sourcelang:${LOCKED_SOURCELANG}`;

    if(country) q += ` sourcecountry:${country}`;

    const allow = domainAllowlistClause(trustedDomains);
    if(allow) q += ` ${allow}`;

    return q.trim();
  }

  function buildGdeltUrl({ query, timespan, sort, maxrecords }){
    const url = new URL(GDELT_ENDPOINT);
    url.searchParams.set("query", query);
    url.searchParams.set("mode", "ArtList");
    url.searchParams.set("format", "json");
    url.searchParams.set("timespan", timespan);
    url.searchParams.set("maxrecords", String(maxrecords));
    if(sort) url.searchParams.set("sort", sort);
    return url.toString();
  }

  async function mapLimit(items, limit, worker){
    const results = new Array(items.length);
    let i = 0;
    const runners = Array.from({length: Math.max(1, limit)}, async () => {
      while(i < items.length){
        const idx = i++;
        results[idx] = await worker(items[idx], idx);
      }
    });
    await Promise.all(runners);
    return results;
  }

  async function fetchTopic(topic, opts){
    const query = (opts.customQuery && opts.customQuery.trim())
      ? buildQueryFromCustom(opts.customQuery, opts.country, opts.trustedDomains)
      : buildQueryFromTerms(topic.terms, opts.country, opts.trustedDomains);

    const url = buildGdeltUrl({
      query,
      timespan: opts.timespan,
      sort: opts.sort,
      maxrecords: opts.perTopic
    });

    const resp = await fetch(url);
    const text = await resp.text();
    let data;
    try { data = JSON.parse(text); }
    catch { throw new Error(`Non-JSON from GDELT (HTTP ${resp.status}): ${text.slice(0,160)}`); }

    const articles = Array.isArray(data) ? data : (data.articles || data.data || []);
    return { topicKey: topic.key, topicLabel: topic.label, query, url, articles };
  }

  // ---------- Decision / Gates ----------
  function isCatalystHeadline(h){
    // "Catalyst" here means: not pure fluff AND has minimum clarity/timing
    if(!h) return false;
    if(h.soft) return false; // strict: soft headlines are filtered out of "kept"
    const c = h.clarity ?? 0;
    const t = h.timing ?? 0;
    // baseline gate (tuned for GDELT titles)
    return (c >= 0.28 && t >= 0.25);
  }

  function computeDecisionMetrics(allHeadlines){
    const kept = allHeadlines.filter(isCatalystHeadline);
    const keptSorted = [...kept].sort((a,b)=>b.trade01-a.trade01);

    const K = Math.max(5, Math.min(15, Math.round(keptSorted.length * 0.25) || 5));
    const topK = keptSorted.slice(0, K);
    const avgTopK = topK.length ? (topK.reduce((s,x)=>s + x.trade01, 0) / topK.length) : 0;

    const strong = kept.filter(h => (h.score10 >= RUNTIME.strongScoreCut) && (h.clarity >= RUNTIME.strongClarityCut));

    let decision = "NO TRADE";
    const reasons = [];

    if(RUNTIME.ideaMode){
      decision = "IDEA MODE";
      reasons.push("Strictness near 0: showing top sensitivity candidates even if strict discipline would say NO TRADE.");
      return { kept, strong, avgTopK, K, decision, reasons };
    }

    if(kept.length < RUNTIME.minKept){
      reasons.push(`Not enough catalyst headlines after filtering (kept ${kept.length} < min ${RUNTIME.minKept}).`);
    }

    if(RUNTIME.requireStrong && strong.length < 1){
      reasons.push(`No strong catalysts found (need ≥1 at score≥${RUNTIME.strongScoreCut} and clarity≥${RUNTIME.strongClarityCut}).`);
    }

    if(avgTopK < RUNTIME.minAvgTrade01){
      reasons.push(`Average tradability too low (avgTopK ${round2(avgTopK)} < min ${round2(RUNTIME.minAvgTrade01)}).`);
    }

    if(reasons.length === 0){
      decision = "TRADE";
      reasons.push("Catalyst density and tradability meet discipline gates.");
    }

    return { kept, strong, avgTopK, K, decision, reasons };
  }

  // ---------- Trade plan math ----------
  function getInstrumentType(ticker){
    return ETF_SET.has(ticker) ? "ETF" : "Stock";
  }

  function computeTradePlan({ ticker, instrumentType, manualPrice, capitalUsd, stockTpPct }){
    const price = Number(manualPrice);
    const cap = Number(capitalUsd);

    if(!isFinite(price) || price <= 0) return { ok:false, error:"Enter a valid current price." };
    if(!isFinite(cap) || cap <= 0) return { ok:false, error:"Enter a valid capital amount." };

    const isETF = instrumentType === "ETF";

    // Entry pullback
    const pullback = isETF ? 0.003 : 0.007;
    const entry = price * (1 - pullback);

    // TP/SL
    const tpPct = isETF ? 0.15 : Math.max(0.20, Math.min(0.25, Number(stockTpPct)/100));
    const slPct = isETF ? -0.08 : -0.10;

    const tp = entry * (1 + tpPct);
    const slStop = entry * (1 + slPct);

    // Stop-limit buffer (still "limit orders only" compliant)
    const stopLimitBuffer = isETF ? 0.003 : 0.005;
    const slLimit = slStop * (1 - stopLimitBuffer);

    // Shares (integer)
    const shares = Math.floor(cap / entry);
    if(shares < 1){
      return { ok:false, error:`Capital too small for 1 share at entry ~$${round2(entry)}.` };
    }

    const notional = shares * entry;

    // Fees/tax
    const feePerOrder = 8;
    const fees = feePerOrder * 2; // buy + sell (TP or SL)
    const taxRate = 0.25;

    // TP scenario
    const grossTp = shares * (tp - entry);
    const netBeforeTaxTp = grossTp - fees;
    const taxTp = Math.max(0, netBeforeTaxTp) * taxRate;
    const netAfterTaxTp = netBeforeTaxTp - taxTp;

    // SL scenario (loss, assume no tax credit)
    const grossSl = shares * (slStop - entry); // negative
    const netAfterTaxSl = grossSl - fees;

    return {
      ok:true,
      shares,
      instrumentType,
      entry: round2(entry),
      tp: round2(tp),
      slStop: round2(slStop),
      slLimit: round2(slLimit),
      notional: round2(notional),
      fees: round2(fees),
      taxRate,
      tpStats: {
        gross: round2(grossTp),
        netBeforeTax: round2(netBeforeTaxTp),
        tax: round2(taxTp),
        netAfterTax: round2(netAfterTaxTp)
      },
      slStats: {
        gross: round2(grossSl),
        netAfterTax: round2(netAfterTaxSl)
      },
      timeStop: isETF ? "15–20 trading days" : "10–15 trading days"
    };
  }

  // ---------- Render ----------
  function setActiveTab(tab){
    document.querySelectorAll(".tab").forEach(t=>{
      t.classList.toggle("active", t.dataset.tab === tab);
    });
    el.viewDecision.style.display = tab==="decision" ? "" : "none";
    el.viewHeadlines.style.display = tab==="headlines" ? "" : "none";
    el.viewTickers.style.display = tab==="tickers" ? "" : "none";
    el.viewDiagnostics.style.display = tab==="diagnostics" ? "" : "none";
    el.viewMethod.style.display = tab==="method" ? "" : "none";
  }

  function renderMethod(){
    el.viewMethod.innerHTML = `
      <div class="item">
        <div class="title">What this app is (and isn’t)</div>
        <div class="smallnote">
          This is a free, deterministic research scanner. It does not predict prices. It scores tradability proxies from headlines (Clarity + Timing + Liquidity + Volatility)
          and maps topics to sector beneficiary bias (long-only). If strictness gates fail, it outputs NO TRADE.
        </div>
      </div>

      <div class="item">
        <div class="title">Headline tradability score (0..1) and impact (1–10)</div>
        <div class="smallnote">
          Each headline gets:
          <span class="mono">clarity (0..1)</span> from title specificity,
          <span class="mono">timing (0..1)</span> from recency decay,
          plus sector average <span class="mono">liq/vol</span>.
          The resulting proxy is mapped to an impact <span class="mono">1..10</span>.
        </div>
        <div class="scoreline">
          <span class="badge"><span class="dot ok"></span><b>Clarity</b> title specificity / action verbs / numbers</span>
          <span class="badge"><span class="dot ok"></span><b>Timing</b> half-life ~48h (swing-oriented)</span>
          <span class="badge"><span class="dot ok"></span><b>Liquidity</b> heuristic table</span>
          <span class="badge"><span class="dot ok"></span><b>Volatility</b> heuristic table</span>
        </div>
      </div>

      <div class="item">
        <div class="title">Trust filters (enforced)</div>
        <div class="smallnote">
          Queries always enforce <span class="mono">sourcelang:english</span> AND your trusted-domain allowlist using <span class="mono">domainis:</span>.
          This improves trust but reduces coverage.
        </div>
      </div>
    `;
  }

  function renderHeadlines(scan){
    const tz = scan.opts.tz;

    const blocks = scan.byTopic.map(t => {
      const items = (t.items || []).map(h => {
        const when = h.seenDate ? fmtDate(new Date(h.seenDate), tz) : "";
        const dotClass = h.score10 >= 7 ? "ok" : (h.score10 <= 3 ? "bad" : "warn");
        const softTag = h.soft ? `<span class="badge"><span class="dot warn"></span>soft</span>` : "";
        return `
          <div class="item">
            <div class="title">
              <a href="${escapeHtml(h.url)}" target="_blank" rel="noopener noreferrer">${escapeHtml(h.title)}</a>
            </div>
            <div class="sub">
              <span>${escapeHtml(h.domain || "")}</span>
              <span>${escapeHtml(when)}</span>
              <span class="badge"><span class="dot ${dotClass}"></span><b>Impact:</b> ${h.score10}/10</span>
              <span class="badge"><b>Clarity:</b> ${round2(h.clarity)}</span>
              <span class="badge"><b>Timing:</b> ${round2(h.timing)}</span>
              ${softTag}
            </div>
            <div class="smallnote mono" style="margin-top:8px; word-break:break-word;">${escapeHtml(h.url)}</div>
          </div>
        `;
      }).join("");

      const err = t.error ? `<div class="item badbox"><div class="title">Error</div><div class="smallnote">${escapeHtml(t.error)}</div></div>` : "";
      return `
        <div class="item">
          <div class="title">${escapeHtml(t.topicLabel)} <span class="badge">top ${t.items.length}</span></div>
          <div class="smallnote">Query: <span class="mono">${escapeHtml(t.query)}</span></div>
          <div class="smallnote">Source: <a href="${escapeHtml(t.url)}" target="_blank" rel="noopener noreferrer">open in GDELT</a></div>
          ${err}
          <div style="margin-top:10px;" class="results">${items || `<div class="item">No results.</div>`}</div>
        </div>
      `;
    }).join("");

    el.viewHeadlines.innerHTML = blocks || `<div class="item">No headlines.</div>`;
  }

  function renderTickers(scan){
    const rows = (scan.tickerTable || []).slice(0, 40).map(x => {
      const itype = getInstrumentType(x.ticker);
      return `
        <div class="item">
          <div class="title">${escapeHtml(x.ticker)} <span class="badge">${escapeHtml(x.group)}</span> <span class="badge">${itype}</span></div>
          <div class="sub">
            <span class="badge"><b>Score:</b> ${x.score100}/100</span>
            <span class="badge"><b>Liq:</b> ${round2(x.liq)}</span>
            <span class="badge"><b>Vol:</b> ${round2(x.vol)}</span>
          </div>
          ${x.drivers?.length ? `
            <div class="smallnote" style="margin-top:8px;">
              Drivers: ${x.drivers.map(d => `${escapeHtml(d.topicKey)} (+${round2(d.add)})`).join(", ")}
            </div>
          ` : `<div class="smallnote" style="margin-top:8px;">No strong drivers detected.</div>`}
        </div>
      `;
    }).join("");
    el.viewTickers.innerHTML = rows || `<div class="item">No ticker table.</div>`;
  }

  function renderDiagnostics(scan){
    const gs = scan.groupShares || [];
    const top3 = gs.slice(0,3);

    const bars = gs.map(g => {
      const pct = Math.round(g.share * 100);
      return `
        <div class="item">
          <div class="title">${escapeHtml(g.group)}</div>
          <div class="sub">
            <span class="badge"><b>Share:</b> ${pct}%</span>
            <span class="badge"><b>Contribution:</b> ${round4(g.value)}</span>
          </div>
          <div class="bar" style="margin-top:10px;"><div style="width:${pct}%;"></div></div>
          <div class="smallnote">
            Interpretation: this share measures how much this sector group contributed to long-bias scoring across all kept headlines.
            If one group dominates, repeated picks from that group (e.g., Energy → XOP) can be a legitimate consequence of the day’s news mix.
          </div>
        </div>
      `;
    }).join("");

    const note = top3.length ? `
      <div class="item warnbox">
        <div class="title">Concentration note</div>
        <div class="smallnote">
          Top contributing groups this scan:
          <b>${escapeHtml(top3.map(x => `${x.group} (${Math.round(x.share*100)}%)`).join(", "))}</b>.
          If Energy is consistently dominant, repeated Energy picks are expected unless the headline mix changes.
        </div>
      </div>
    ` : "";

    el.viewDiagnostics.innerHTML = note + (bars || `<div class="item">No diagnostics available.</div>`);
  }

  function renderDecision(scan){
    const tz = scan.opts.tz;
    const dec = scan.decisionMetrics;

    const decisionBadge = dec.decision === "TRADE"
      ? `<span class="badge"><span class="dot ok"></span><b>TRADE</b></span>`
      : (dec.decision === "IDEA MODE"
        ? `<span class="badge"><span class="dot warn"></span><b>IDEA MODE</b></span>`
        : `<span class="badge"><span class="dot bad"></span><b>NO TRADE</b></span>`);

    const reasons = dec.reasons.map(r => `<div class="smallnote">• ${escapeHtml(r)}</div>`).join("");

    const kpi = `
      <div class="kpi">
        <div class="box"><b>raw headlines</b><span>${scan.countHeadlines}</span></div>
        <div class="box"><b>kept (catalysts)</b><span>${dec.kept.length} (min ${RUNTIME.minKept})</span></div>
        <div class="box"><b>strong catalysts</b><span>${dec.strong.length} (cut score≥${RUNTIME.strongScoreCut}, clarity≥${RUNTIME.strongClarityCut})</span></div>
        <div class="box"><b>avgTopK</b><span>${round2(dec.avgTopK)} (min ${round2(RUNTIME.minAvgTrade01)})</span></div>
      </div>
    `;

    const picks = (scan.topPicks || []).filter(p => p.score > 0).slice(0,3);

    const picksBlock = picks.length ? picks.map((p, idx) => {
      const itype = getInstrumentType(p.ticker);
      const drivers = (p.drivers || []).map((d) => {
        const when = d.seenDate ? fmtDate(new Date(d.seenDate), tz) : "";
        return `
          <div class="sub" style="margin-top:6px;">
            <span class="badge"><span class="dot ok"></span>+${round2(d.add)} driver</span>
            <span>${escapeHtml(d.topicKey)}</span>
            <a href="${escapeHtml(d.url)}" target="_blank" rel="noopener noreferrer">${escapeHtml(d.title)}</a>
            <span>${escapeHtml(when)}</span>
          </div>
        `;
      }).join("");

      const priceId = `price_${p.ticker}_${idx}`;
      const outId = `plan_${p.ticker}_${idx}`;

      return `
        <div class="item">
          <div class="title">${idx+1}) ${escapeHtml(p.ticker)} <span class="badge">${escapeHtml(p.group)}</span> <span class="badge">${itype}</span></div>
          <div class="sub">
            <span class="badge"><span class="dot ok"></span><b>Setup score:</b> ${p.score100}/100</span>
            <span class="badge"><b>Liq:</b> ${round2(p.liq)}</span>
            <span class="badge"><b>Vol:</b> ${round2(p.vol)}</span>
          </div>

          <div class="smallnote" style="margin-top:8px;">
            Reasoning: this ticker has the highest cumulative sensitivity to the strongest catalysts in its mapped sector group, given its liquidity/volatility profile.
            If you see repeats (e.g., XOP), check Diagnostics: it may reflect genuine sector dominance in today’s headline mix.
          </div>

          <div class="hr"></div>

          <div class="title">Discipline Trade Plan (manual price input)</div>
          <div class="row">
            <div>
              <label>Enter current price (USD)</label>
              <input id="${priceId}" type="number" step="0.01" placeholder="e.g., 39.25" />
            </div>
            <div>
              <label>Capital used (USD)</label>
              <input type="text" value="$${escapeHtml(String(el.capital.value || "1500"))}" disabled />
            </div>
          </div>
          <div id="${outId}" class="smallnote warnbox" style="margin-top:10px; padding:10px; border-radius:12px;">
            Enter a price to generate LIMIT entry + OCO exits + fees/tax math.
          </div>

          ${drivers ? `<div style="margin-top:10px;"><div class="sub"><b>Top drivers:</b></div>${drivers}</div>` : ""}
        </div>
      `;
    }).join("") : `
      <div class="item warnbox">
        <div class="title">No positive-scoring picks</div>
        <div class="smallnote">
          With today’s trusted-only headlines, the model did not find any long-bias candidates (positive sensitivity).
          Try increasing lookback (12h → 1day) or switching to Idea Mode for exploratory candidates.
        </div>
      </div>
    `;

    const header = `
      <div class="item ${dec.decision==="TRADE" ? "okbox" : (dec.decision==="IDEA MODE" ? "warnbox" : "badbox")}">
        <div class="title">Decision ${decisionBadge}</div>
        <div class="sub">
          <span class="badge"><b>Strictness:</b> ${Math.round(RUNTIME.strictness*100)}%</span>
          <span class="badge"><b>Trusted-only:</b> enforced</span>
          <span class="badge"><b>Language:</b> english</span>
          <span class="badge"><b>Version:</b> ${escapeHtml(VERSION)}</span>
        </div>
        ${kpi}
        <div class="hr"></div>
        ${reasons}
        <div class="smallnote" style="margin-top:10px;">
          Policy reminder: one active trade at a time; use OCO; honor the time stop.
        </div>
      </div>
    `;

    el.viewDecision.innerHTML = header + picksBlock;

    // After render, attach plan calculators
    picks.forEach((p, idx) => {
      const priceId = `price_${p.ticker}_${idx}`;
      const outId = `plan_${p.ticker}_${idx}`;
      const priceEl = document.getElementById(priceId);
      const outEl = document.getElementById(outId);

      if(!priceEl || !outEl) return;

      const instrumentType = getInstrumentType(p.ticker);

      const recalc = () => {
        const price = Number(priceEl.value);
        const cap = Number(el.capital.value || 1500);
        const stockTp = Number(el.stockTp.value || 22);

        const plan = computeTradePlan({
          ticker: p.ticker,
          instrumentType,
          manualPrice: price,
          capitalUsd: cap,
          stockTpPct: stockTp
        });

        if(!plan.ok){
          outEl.className = "smallnote warnbox";
          outEl.style.marginTop = "10px";
          outEl.style.padding = "10px";
          outEl.style.borderRadius = "12px";
          outEl.innerHTML = escapeHtml(plan.error || "Enter inputs.");
          return;
        }

        const entryStyle = instrumentType === "ETF" ? "Entry pullback: -0.3%" : "Entry pullback: -0.7%";
        const tpRule = instrumentType === "ETF" ? "TP: +15%" : `TP: +${Math.round((plan.tp/plan.entry - 1)*100)}% (stock TP setting)`;
        const slRule = instrumentType === "ETF" ? "SL: -8%" : "SL: -10%";
        const oco = `
          BUY LIMIT ${p.ticker}: <b>$${plan.entry}</b><br/>
          OCO exits:<br/>
          • Take-Profit LIMIT: <b>$${plan.tp}</b><br/>
          • Stop-Loss STOP-LIMIT: stop <b>$${plan.slStop}</b>, limit <b>$${plan.slLimit}</b><br/>
          Time stop: <b>${plan.timeStop}</b> (exit if TP/SL not hit).<br/>
        `;

        const tpLine = `
          TP scenario (net): gross $${plan.tpStats.gross}, fees $${plan.fees}, tax $${plan.tpStats.tax} → <b>$${plan.tpStats.netAfterTax}</b>
        `;
        const slLine = `
          SL scenario (net): gross $${plan.slStats.gross}, fees $${plan.fees} → <b>$${plan.slStats.netAfterTax}</b>
        `;

        outEl.className = "smallnote okbox";
        outEl.style.marginTop = "10px";
        outEl.style.padding = "10px";
        outEl.style.borderRadius = "12px";
        outEl.innerHTML = `
          <div class="sub">
            <span class="badge"><span class="dot ok"></span><b>${instrumentType}</b></span>
            <span class="badge"><b>Shares:</b> ${plan.shares}</span>
            <span class="badge"><b>Notional:</b> $${plan.notional}</span>
            <span class="badge"><b>Fees:</b> $${plan.fees}</span>
            <span class="badge"><b>Tax:</b> 25% on gains</span>
          </div>
          <div class="smallnote" style="margin-top:8px;">
            <b>${entryStyle}</b> | ${tpRule} | ${slRule}
          </div>
          <div class="smallnote" style="margin-top:8px;">
            ${oco}
          </div>
          <div class="smallnote" style="margin-top:8px;">
            ${tpLine}<br/>
            ${slLine}
          </div>
        `;
      };

      priceEl.addEventListener("input", recalc);
    });
  }

  function renderAll(scan){
    el.meta.textContent = `Scan @ ${fmtDate(new Date(scan.createdAt), scan.opts.tz)} | headlines: ${scan.countHeadlines} | mode: ${scan.decisionMetrics.decision}`;
    renderDecision(scan);
    renderHeadlines(scan);
    renderTickers(scan);
    renderDiagnostics(scan);
    renderMethod();
  }

  // ---------- History ----------
  const STORAGE_KEY = "trade_scanner_history_v6";
  const DOMAINS_KEY = "trade_scanner_trusted_domains_v1";

  function loadHistory(){
    const raw = localStorage.getItem(STORAGE_KEY);
    let arr = [];
    try { arr = raw ? JSON.parse(raw) : []; } catch {}
    return Array.isArray(arr) ? arr : [];
  }

  function saveHistory(arr){
    localStorage.setItem(STORAGE_KEY, JSON.stringify(arr.slice(0, 30)));
  }

  function refreshHistoryDropdown(){
    const arr = loadHistory();
    el.history.innerHTML = "";
    const opt0 = document.createElement("option");
    opt0.value = "";
    opt0.textContent = "— Select saved scan —";
    el.history.appendChild(opt0);

    for(let i=0;i<arr.length;i++){
      const s = arr[i];
      const o = document.createElement("option");
      o.value = String(i);
      const dt = new Date(s.createdAt);
      const top = (s.topPicks || []).map(x=>x.ticker).join(", ");
      o.textContent = `${i+1}) ${dt.toLocaleString()} | Top: ${top || "—"}`;
      el.history.appendChild(o);
    }
  }

  function clearHistory(){
    localStorage.removeItem(STORAGE_KEY);
    refreshHistoryDropdown();
    setStatus("History cleared.");
  }

  function loadFromHistoryIndex(idx){
    const arr = loadHistory();
    const scan = arr[idx];
    if(!scan) return;
    lastScan = scan;
    setStatus("Loaded saved scan (no re-fetch).");
    renderAll(scan);
    el.saveBtn.disabled = false;
    el.exportBtn.disabled = false;
  }

  // ---------- Export / Save ----------
  function saveCurrent(){
    if(!lastScan) return;
    const arr = loadHistory();
    arr.unshift(lastScan);
    saveHistory(arr);
    refreshHistoryDropdown();
    setStatus("Saved to History.");
  }

  function exportJson(){
    if(!lastScan) return;
    const blob = new Blob([JSON.stringify(lastScan, null, 2)], { type:"application/json" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = `scan_${new Date(lastScan.createdAt).toISOString().replaceAll(":","-")}.json`;
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  }

  // ---------- Domains storage ----------
  function loadDomains(){
    const raw = localStorage.getItem(DOMAINS_KEY);
    if(!raw) return TRUSTED_DOMAINS_DEFAULT;
    try{
      const arr = JSON.parse(raw);
      return Array.isArray(arr) && arr.length ? arr : TRUSTED_DOMAINS_DEFAULT;
    }catch{
      return TRUSTED_DOMAINS_DEFAULT;
    }
  }

  function saveDomains(domains){
    localStorage.setItem(DOMAINS_KEY, JSON.stringify(domains));
  }

  function resetDomains(){
    el.trustedDomains.value = TRUSTED_DOMAINS_DEFAULT.join("\n");
    saveDomains(TRUSTED_DOMAINS_DEFAULT);
    setStatus("Trusted domain list reset.");
  }

  function persistDomainsFromUI(){
    const domains = parseDomains(el.trustedDomains.value);
    if(domains.length < 5){
      setStatus("Domain list too small. Add more trusted domains or reset.", true);
      return;
    }
    saveDomains(domains);
    setStatus(`Saved trusted domains (${domains.length}).`);
  }

  // ---------- Main run ----------
  async function runScan(){
    applyStrictnessFromUI();
    setStatus("");
    el.runBtn.disabled = true;
    el.saveBtn.disabled = true;
    el.exportBtn.disabled = true;

    const nowUtc = new Date();

    const trustedDomains = parseDomains(el.trustedDomains.value);
    if(trustedDomains.length < 5){
      setStatus("Trusted domains list is empty/too small. Reset it and try again.", true);
      el.runBtn.disabled = false;
      return;
    }

    const opts = {
      timespan: el.timespan.value,
      sort: el.sort.value,
      perTopic: Math.max(1, Math.min(25, Number(el.perTopic.value || 5))),
      concurrency: Math.max(1, Math.min(10, Number(el.concurrency.value || 4))),
      tz: el.tz.value || "Asia/Jerusalem",
      country: (el.country.value || "").trim(),
      customQuery: el.customQuery.value || "",
      trustedDomains
    };

    setPills([
      ["timespan", opts.timespan],
      ["sort", opts.sort || "relevance"],
      ["perTopic", opts.perTopic],
      ["concurrency", opts.concurrency],
      ["sourcelang", "english (locked)"],
      ["trustedDomains", trustedDomains.length]
    ]);

    setStatus("Fetching trusted English headlines from GDELT…");

    let byTopic;
    try{
      byTopic = await mapLimit(TOPICS, opts.concurrency, async (topic) => {
        try{
          const r = await fetchTopic(topic, opts);
          return { ...r, error: null };
        }catch(e){
          return { topicKey: topic.key, topicLabel: topic.label, query: "", url: "", articles: [], error: String(e.message || e) };
        }
      });
    }catch(e){
      setStatus(String(e.message || e), true);
      el.runBtn.disabled = false;
      return;
    }

    // Normalize & score headlines
    const all = [];
    const scoredByTopic = byTopic.map(t => {
      const items = (t.articles || []).map(a => {
        const title = a.title || "(no title)";
        const url = a.url || a.url_mobile || "#";
        const domain = a.domain || "";
        const seenDate = parseGdeltSeenDate(a.seendate || a.seenDate || "");

        const { score10, clarity, timing } = headlineImpactScore({
          topicKey: t.topicKey, title, seenDate
        }, nowUtc);

        const trade01 = clamp01(score10 / 10);
        const soft = isSoftHeadline(title);

        const h = {
          topicKey: t.topicKey,
          topicLabel: t.topicLabel,
          title, url, domain,
          seenDate: seenDate ? seenDate.toISOString() : null,
          score10,
          trade01,
          clarity, timing,
          soft
        };
        all.push(h);
        return h;
      });

      return {
        topicKey: t.topicKey,
        topicLabel: t.topicLabel,
        query: t.query,
        url: t.url,
        error: t.error,
        items
      };
    });

    // Decision metrics computed from all headlines
    const decisionMetrics = computeDecisionMetrics(all);

    // For ticker scoring, use "kept" headlines (catalysts) in strict modes; in idea mode, use all.
    const scoringHeadlines = RUNTIME.ideaMode ? all : decisionMetrics.kept;

    const { tickerTable, groupShares } = aggregateTickerScores(scoringHeadlines);

    // Top picks: purely by score (no artificial de-duplication)
    const topPicks = tickerTable.slice(0, 3);

    const scan = {
      createdAt: nowUtc.toISOString(),
      opts,
      byTopic: scoredByTopic,
      countHeadlines: all.length,
      decisionMetrics,
      tickerTable,
      groupShares,
      topPicks
    };

    lastScan = scan;

    const errCount = scoredByTopic.filter(x=>x.error).length;
    if(all.length === 0){
      setStatus("No headlines returned. Increase lookback or adjust trusted domains.", true);
    } else if(errCount){
      setStatus(`Completed with ${errCount} topic errors (see Headlines tab).`, true);
    } else {
      setStatus("Completed.");
    }

    renderAll(scan);
    el.runBtn.disabled = false;
    el.saveBtn.disabled = false;
    el.exportBtn.disabled = false;
  }

  // ---------- Events ----------
  document.querySelectorAll(".tab").forEach(t=>{
    t.addEventListener("click", () => setActiveTab(t.dataset.tab));
  });

  el.strictness.addEventListener("input", applyStrictnessFromUI);

  el.runBtn.addEventListener("click", runScan);
  el.saveBtn.addEventListener("click", saveCurrent);
  el.exportBtn.addEventListener("click", exportJson);
  el.clearHistoryBtn.addEventListener("click", clearHistory);

  el.history.addEventListener("change", () => {
    const v = el.history.value;
    if(!v) return;
    loadFromHistoryIndex(Number(v));
  });

  el.resetDomainsBtn.addEventListener("click", resetDomains);
  el.saveDomainsBtn.addEventListener("click", persistDomainsFromUI);

  // Init
  el.trustedDomains.value = loadDomains().join("\n");
  refreshHistoryDropdown();
  applyStrictnessFromUI();
  setActiveTab("decision");
  renderMethod();
})();
</script>
</body>
</html>
