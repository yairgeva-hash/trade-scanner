<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Speculative Trade Advisor (Free, GDELT)</title>
  <style>
    :root{
      --bg:#070b13; --panel:#0c1426; --panel2:#0a1020;
      --border:#17284a; --border2:#22365f;
      --text:#e8eefc; --muted:rgba(232,238,252,.72);
      --accent:#2a5cff; --bad:#ff8080; --ok:#93ffb4; --warn:#ffd27a;
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
    }
    body{margin:0;background:var(--bg);color:var(--text);}
    header{padding:18px 18px;border-bottom:1px solid var(--border);background:#070c18;}
    header h1{margin:0 0 6px;font-size:18px;}
    header p{margin:0;color:var(--muted);font-size:13px;line-height:1.35;}
    main{padding:16px 18px;max-width:1280px;margin:0 auto;}
    .grid{display:grid;grid-template-columns:1fr;gap:12px;}
    @media(min-width:980px){.grid{grid-template-columns:440px 1fr;}}
    .card{background:linear-gradient(180deg,#0c152a,#0a1020);border:1px solid var(--border);border-radius:16px;padding:14px;}
    label{display:block;font-size:12px;color:var(--muted);margin:10px 0 6px;}
    input,select,textarea,button{
      width:100%;box-sizing:border-box;border-radius:12px;border:1px solid var(--border2);
      background:var(--panel2);color:var(--text);padding:10px 11px;font-size:14px;
    }
    textarea{min-height:86px;resize:vertical;}
    .row{display:grid;grid-template-columns:1fr 1fr;gap:10px;}
    .row3{display:grid;grid-template-columns:1fr 1fr 1fr;gap:10px;}
    .actions{display:grid;grid-template-columns:1fr 1fr;gap:10px;margin-top:12px;}
    button{cursor:pointer;font-weight:800;}
    button.primary{background:var(--accent);border-color:var(--accent);}
    button.ghost{background:transparent;}
    button:disabled{opacity:.65;cursor:not-allowed;}
    .status{margin-top:10px;font-size:13px;color:var(--muted);}
    .status.error{color:var(--bad);}
    .status.warn{color:var(--warn);}
    .pillbar{display:flex;flex-wrap:wrap;gap:8px;margin-top:10px;}
    .pill{border:1px solid var(--border2);background:rgba(10,16,32,.7);padding:6px 10px;border-radius:999px;font-size:12px;color:var(--muted);}
    .rightHead{display:flex;align-items:flex-end;justify-content:space-between;gap:12px;margin-bottom:10px;}
    .rightHead h2{margin:0;font-size:16px;}
    .rightHead .small{font-size:12px;color:var(--muted);text-align:right;}
    .tabs{display:flex;gap:8px;flex-wrap:wrap;margin:0 0 12px;}
    .tab{padding:8px 10px;border-radius:999px;border:1px solid var(--border2);background:rgba(10,16,32,.65);font-size:12px;color:var(--muted);cursor:pointer;user-select:none;}
    .tab.active{border-color:var(--accent);color:var(--text);}
    .results{display:grid;gap:10px;}
    .item{border-radius:14px;border:1px solid var(--border);background:rgba(10,16,32,.7);padding:12px;}
    .item .title{margin:0 0 6px;font-weight:900;line-height:1.25;}
    .item a{color:#9dc0ff;text-decoration:none;}
    .item a:hover{text-decoration:underline;}
    .sub{display:flex;gap:10px;flex-wrap:wrap;font-size:12px;color:var(--muted);}
    .badge{display:inline-flex;align-items:center;gap:6px;border:1px solid var(--border2);background:#070c18;padding:5px 9px;border-radius:999px;}
    .dot{width:8px;height:8px;border-radius:999px;background:var(--muted);display:inline-block;}
    .dot.ok{background:var(--ok);}
    .dot.bad{background:var(--bad);}
    .dot.warn{background:var(--warn);}
    .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace;}
    .smallnote{font-size:12px;color:var(--muted);line-height:1.35;margin-top:8px;}
    .hr{height:1px;background:var(--border);margin:10px 0;}
    .sliderRow{display:flex;gap:10px;align-items:center;}
    input[type="range"]{padding:0;height:24px;background:transparent;border:none;}
    .kpi{display:flex;gap:10px;flex-wrap:wrap;margin-top:10px;}
    .kpi .badge b{color:var(--text);}
    .danger{color:var(--bad);}
    .good{color:var(--ok);}
    .warnText{color:var(--warn);}
  </style>
</head>

<body>
<header>
  <h1>Speculative Trade Advisor (Free, GDELT)</h1>
  <p>
    Free-only deterministic scanner: fetches English headlines (GDELT DOC 2.0), filters to trusted domains locally, scores tradability (1–10),
    and produces a disciplined plan (manual price entry → LIMIT + TP/SL + fees/tax math). Research tool only.
  </p>
</header>

<main class="grid">
  <!-- LEFT -->
  <section class="card">
    <div class="row">
      <div>
        <label>Lookback (TIMESPAN)</label>
        <select id="timespan">
          <option value="1h">Last 1 hour</option>
          <option value="6h">Last 6 hours</option>
          <option value="12h">Last 12 hours</option>
          <option value="1day">Last 1 day</option>
          <option value="3day">Last 3 days</option>
          <option value="1week" selected>Last 1 week</option>
        </select>
      </div>
      <div>
        <label>Sort</label>
        <select id="sort">
          <option value="datedesc" selected>Date (newest first)</option>
          <option value="">Relevance</option>
          <option value="toneasc">Tone (most negative)</option>
          <option value="tonedesc">Tone (most positive)</option>
        </select>
      </div>
    </div>

    <div class="row3">
      <div>
        <label>Headlines / topic (final)</label>
        <input id="perTopic" type="number" min="1" max="25" value="5" />
      </div>
      <div>
        <label>Concurrency</label>
        <input id="concurrency" type="number" min="1" max="10" value="4" />
      </div>
      <div>
        <label>Time zone display</label>
        <select id="tz">
          <option value="Asia/Jerusalem" selected>Asia/Jerusalem</option>
          <option value="UTC">UTC</option>
          <option value="America/New_York">America/New_York</option>
          <option value="Europe/London">Europe/London</option>
        </select>
      </div>
    </div>

    <label>Strictness (0 = Idea Mode, 100 = Strict)</label>
    <div class="sliderRow">
      <input id="strictness" type="range" min="0" max="100" value="40" />
      <input id="strictnessNum" type="number" min="0" max="100" value="40" style="width:90px" />
    </div>
    <div id="strictExplain" class="smallnote"></div>

    <div class="hr"></div>

    <label>English only</label>
    <div class="pillbar">
      <div class="pill">Locked: <span class="mono">sourcelang:english</span></div>
    </div>

    <label>Optional filter (applies to all topics)</label>
    <input id="country" placeholder="sourcecountry (e.g. unitedstates, israel, unitedkingdom)" />

    <div class="hr"></div>

    <label>Trusted sources preset</label>
    <select id="trustedPreset">
      <option value="expanded" selected>Expanded trusted (recommended)</option>
      <option value="core">Core wires only (Reuters, AP, Bloomberg)</option>
      <option value="off">OFF (no domain filtering)</option>
    </select>

    <label>Domain matching</label>
    <select id="domainMode">
      <option value="broad" selected>Broad match (recommended, fewer “no results”)</option>
      <option value="exact">Exact match only</option>
    </select>

    <label>Trusted domains allowlist (ENFORCED unless preset=OFF)</label>
    <textarea id="domainList" class="mono"></textarea>

    <div class="actions">
      <button id="resetDomains" class="ghost">Reset to Preset</button>
      <button id="saveDomains" class="ghost">Save List</button>
    </div>

    <div class="hr"></div>

    <label>Optional: custom topic query override (advanced)</label>
    <textarea id="customQuery" placeholder='Leave blank. Example: ("sanctions" OR "export controls")'></textarea>
    <div class="smallnote">
      Note: trusted domains are filtered locally (after fetch) to avoid GDELT query-length errors.
    </div>

    <div class="actions">
      <button id="runBtn" class="primary">Run Scan</button>
      <button id="exportBtn" class="ghost" disabled>Export JSON</button>
    </div>

    <div id="status" class="status"></div>
    <div id="pills" class="pillbar"></div>

    <div class="hr"></div>

    <label>History (localStorage)</label>
    <select id="history"></select>
    <div class="actions" style="grid-template-columns:1fr 1fr;">
      <button id="saveBtn" class="ghost" disabled>Save to History</button>
      <button id="clearHistoryBtn" class="ghost">Clear History</button>
    </div>
  </section>

  <!-- RIGHT -->
  <section class="card">
    <div class="rightHead">
      <h2>Results</h2>
      <div id="meta" class="small"></div>
    </div>

    <div class="tabs">
      <div class="tab active" data-tab="decision">Trade Decision</div>
      <div class="tab" data-tab="headlines">Headlines by Topic</div>
      <div class="tab" data-tab="tickers">Ticker Table</div>
      <div class="tab" data-tab="diag">Diagnostics</div>
      <div class="tab" data-tab="method">Method</div>
    </div>

    <div id="viewDecision" class="results"></div>
    <div id="viewHeadlines" class="results" style="display:none;"></div>
    <div id="viewTickers" class="results" style="display:none;"></div>
    <div id="viewDiag" class="results" style="display:none;"></div>
    <div id="viewMethod" class="results" style="display:none;"></div>
  </section>
</main>

<script>
(() => {
  const GDELT_ENDPOINT = "https://api.gdeltproject.org/api/v2/doc/doc";
  const STORAGE_KEY = "trade_scanner_history_v3";
  const DOMAIN_KEY = "trade_scanner_domains_v3";

  // Universe
  const TICKER_GROUPS = {
    defense: ["PPA","ITA","LMT","NOC","GD","RTX","BA","HII","LHX","TDG","AVAV","KTOS"],
    cyber: ["CIBR","HACK","PANW","CRWD","FTNT","ZS","OKTA","NET"],
    semis: ["SMH","SOXX","NVDA","AVGO","TSM","MU","ASML","AMAT","LRCX","KLAC","AMD","ARM","MRVL"],
    energy: ["XLE","XOP","LNG","VLO","CVX","XOM","SLB","HAL","OIH"],
    shipping: ["INSW","STNG","TK","ZIM","DAC"],
    uranium: ["URNM","URA","CCJ","UEC","LEU"],
    water_agri: ["PHO","MOO","DBA","NTR","MOS","CF","DE"],
    insurers: ["KIE","CB","TRV","ALL","AIG"],
    gold: ["GLD","IAU","GDX"]
  };

  const ETF_SET = new Set([
    "PPA","ITA","CIBR","HACK","SMH","SOXX","XLE","XOP","OIH","URNM","URA","PHO","MOO","DBA","KIE","GLD","IAU","GDX"
  ]);

  // Topics
  const TOPICS = [
    { key:"geopolitics", label:"geopolitics", terms:['geopolitics','"regional tensions"','"border clash"','"military buildup"','"diplomatic crisis"'] },
    { key:"sanctions", label:"sanctions", terms:['sanctions','"export controls"','"blacklist"','"secondary sanctions"','"asset freeze"'] },
    { key:"ceasefire", label:"ceasefire", terms:['ceasefire','truce','"peace talks"','"temporary halt"'] },
    { key:"war", label:"war", terms:['war','airstrike','"missile attack"','"ground offensive"','"troop deployment"'] },
    { key:"regulation", label:"regulation", terms:['regulation','"regulatory crackdown"','antitrust','"compliance rule"','SEC','FTC'] },
    { key:"tariff", label:"tariff", terms:['tariff','"trade war"','"import duty"','"export ban"'] },
    { key:"cyber", label:"cyber", terms:['cyber','ransomware','"data breach"','DDoS','"zero-day"','hackers'] },
    { key:"earthquake", label:"earthquake", terms:['earthquake','seismic','aftershock','magnitude'] },
    { key:"flood", label:"flood", terms:['flood','"flash flood"','"storm surge"','"river overflow"'] },
    { key:"wildfire", label:"wildfire", terms:['wildfire','"forest fire"','"evacuation order"'] },
    { key:"inflation", label:"inflation", terms:['inflation','CPI','PCE','"price pressures"','"core inflation"'] },
    { key:"rates", label:"rates", terms:['"interest rate"','"rate hike"','"rate cut"','"policy rate"','"Federal Reserve"','ECB','BoE'] },
    { key:"recession", label:"recession", terms:['recession','"GDP contraction"','"yield curve"','"job losses"','"hard landing"'] },
    { key:"OPEC", label:"OPEC", terms:['OPEC','"OPEC+"','"oil output"','"production cut"','quota'] },
    { key:"oil", label:"oil", terms:['"crude oil"','Brent','WTI','"oil prices"','"oil supply"'] }
  ];

  // Topic -> sector weights (beneficiary bias for long-only picks)
  const TOPIC_SECTOR_WEIGHTS = {
    geopolitics: { defense:0.8, energy:0.6, shipping:0.5, gold:0.6, insurers:0.2 },
    sanctions:   { energy:0.5, shipping:0.5, defense:0.4, semis:0.25, gold:0.3 },
    ceasefire:   { shipping:0.6, energy:0.25, gold:0.15, defense:0.15 },
    war:         { defense:0.9, energy:0.6, gold:0.7, shipping:0.4 },
    regulation:  { insurers:0.35, semis:0.25, energy:0.2 },
    tariff:      { semis:0.45, shipping:0.35, energy:0.2 },
    cyber:       { cyber:0.95 },
    earthquake:  { insurers:0.25, water_agri:0.25, energy:0.15 },
    flood:       { insurers:0.25, water_agri:0.35, energy:0.15 },
    wildfire:    { insurers:0.25, water_agri:0.35, energy:0.15 },
    inflation:   { gold:0.35, insurers:0.25, energy:0.2 },
    rates:       { insurers:0.35, gold:0.25 },
    recession:   { gold:0.45, insurers:0.25 },
    OPEC:        { energy:0.9, shipping:0.35 },
    oil:         { energy:0.85, shipping:0.3 }
  };

  // Heuristic Liquidity (0..1)
  const LIQ = Object.fromEntries([
    ["PPA",0.75],["ITA",0.8],["CIBR",0.8],["HACK",0.7],["SMH",0.85],["SOXX",0.85],
    ["XLE",0.9],["XOP",0.75],["OIH",0.6],["KIE",0.65],["URNM",0.55],["URA",0.65],
    ["PHO",0.55],["MOO",0.55],["DBA",0.6],["GLD",0.95],["IAU",0.85],["GDX",0.75],
    ["NVDA",0.95],["AVGO",0.9],["TSM",0.9],["AMD",0.9],["XOM",0.9],["CVX",0.85],
    ["BA",0.85],["RTX",0.8],["LMT",0.75],["PANW",0.8],["CRWD",0.8],["NET",0.75],
    ["AVAV",0.55],["KTOS",0.5],["HII",0.45],["INSW",0.45],["STNG",0.5],["TK",0.4],
    ["ZIM",0.6],["DAC",0.45],["UEC",0.45],["LEU",0.45]
  ]);
  // Heuristic Volatility (0..1)
  const VOL = Object.fromEntries([
    ["NVDA",0.9],["AMD",0.85],["ARM",0.85],["MRVL",0.8],["MU",0.85],
    ["XOP",0.8],["OIH",0.85],["HAL",0.75],["SLB",0.7],
    ["ZIM",0.9],["STNG",0.75],["INSW",0.6],
    ["CRWD",0.8],["PANW",0.65],["NET",0.75],["FTNT",0.65],
    ["GLD",0.35],["GDX",0.6],["IAU",0.3],
    ["LMT",0.35],["NOC",0.35],["RTX",0.4],["BA",0.6],["KTOS",0.7],["AVAV",0.65],
    ["KIE",0.35],["AIG",0.45],["ALL",0.35]
  ]);
  const DEFAULT_LIQ = 0.55;
  const DEFAULT_VOL = 0.55;

  // Trusted domains presets (you can edit)
  const PRESETS = {
    core: [
      "reuters.com",
      "apnews.com",
      "bloomberg.com"
    ],
    expanded: [
      "reuters.com","apnews.com","bloomberg.com",
      "ft.com","wsj.com","economist.com",
      "bbc.co.uk","bbc.com","theguardian.com",
      "nytimes.com","washingtonpost.com",
      "cnbc.com","marketwatch.com","finance.yahoo.com",
      "aljazeera.com","cnn.com",
      "axios.com","politico.com"
    ]
  };

  // UI refs
  const el = {
    timespan: document.getElementById("timespan"),
    sort: document.getElementById("sort"),
    perTopic: document.getElementById("perTopic"),
    concurrency: document.getElementById("concurrency"),
    tz: document.getElementById("tz"),
    strictness: document.getElementById("strictness"),
    strictnessNum: document.getElementById("strictnessNum"),
    strictExplain: document.getElementById("strictExplain"),
    country: document.getElementById("country"),
    trustedPreset: document.getElementById("trustedPreset"),
    domainMode: document.getElementById("domainMode"),
    domainList: document.getElementById("domainList"),
    resetDomains: document.getElementById("resetDomains"),
    saveDomains: document.getElementById("saveDomains"),
    customQuery: document.getElementById("customQuery"),
    runBtn: document.getElementById("runBtn"),
    exportBtn: document.getElementById("exportBtn"),
    status: document.getElementById("status"),
    pills: document.getElementById("pills"),
    meta: document.getElementById("meta"),
    history: document.getElementById("history"),
    saveBtn: document.getElementById("saveBtn"),
    clearHistoryBtn: document.getElementById("clearHistoryBtn"),
    viewDecision: document.getElementById("viewDecision"),
    viewHeadlines: document.getElementById("viewHeadlines"),
    viewTickers: document.getElementById("viewTickers"),
    viewDiag: document.getElementById("viewDiag"),
    viewMethod: document.getElementById("viewMethod")
  };

  let lastScan = null;

  // Helpers
  const clamp01 = (x) => Math.max(0, Math.min(1, x));
  const round2 = (x) => Math.round(x*100)/100;
  const round4 = (x) => Math.round(x*10000)/10000;

  function setStatus(msg, type=""){
    el.status.textContent = msg || "";
    el.status.className = "status" + (type ? (" " + type) : "");
  }
  function setPills(pairs){
    el.pills.innerHTML = "";
    for(const [k,v] of pairs){
      const d = document.createElement("div");
      d.className = "pill";
      d.textContent = `${k}: ${v}`;
      el.pills.appendChild(d);
    }
  }
  function escapeHtml(s){
    return String(s ?? "")
      .replaceAll("&","&amp;").replaceAll("<","&lt;").replaceAll(">","&gt;")
      .replaceAll('"',"&quot;").replaceAll("'","&#039;");
  }
  function fmtDate(dt, tz){
    try{
      return new Intl.DateTimeFormat(undefined, {
        timeZone: tz, year:"numeric", month:"2-digit", day:"2-digit",
        hour:"2-digit", minute:"2-digit", second:"2-digit"
      }).format(dt);
    }catch{ return dt.toISOString(); }
  }
  function tickerLiquidity(t){ return LIQ[t] ?? DEFAULT_LIQ; }
  function tickerVol(t){ return VOL[t] ?? DEFAULT_VOL; }
  function isETF(t){ return ETF_SET.has(t); }

  function getDomainFromArticle(a){
    const d = (a.domain || "").trim().toLowerCase();
    if(d) return d;
    const u = a.url || "";
    try { return new URL(u).hostname.toLowerCase(); }
    catch { return ""; }
  }

  function normalizeCountry(s){
    return (s || "").trim().toLowerCase().replace(/\s+/g,"");
  }

  function loadDomains(){
    const raw = localStorage.getItem(DOMAIN_KEY);
    if(raw){
      try{
        const o = JSON.parse(raw);
        if(o && typeof o.text === "string") return o.text;
      }catch{}
    }
    return PRESETS.expanded.join("\n");
  }
  function saveDomains(text){
    localStorage.setItem(DOMAIN_KEY, JSON.stringify({ text }));
  }
  function applyPreset(preset){
    if(preset === "off"){
      el.domainList.value = PRESETS.expanded.join("\n");
      return;
    }
    el.domainList.value = (PRESETS[preset] || PRESETS.expanded).join("\n");
  }
  function getAllowlist(){
    const preset = el.trustedPreset.value;
    if(preset === "off") return [];
    const lines = el.domainList.value.split("\n")
      .map(x => x.trim().toLowerCase())
      .filter(Boolean);
    // de-dup
    return Array.from(new Set(lines));
  }
  function domainAllowed(domain, allowlist, mode){
    if(!allowlist.length) return true; // OFF
    if(!domain) return false;
    if(mode === "exact"){
      return allowlist.includes(domain);
    }
    // broad: allow exact OR any subdomain ending with allowlisted root
    for(const root of allowlist){
      if(domain === root) return true;
      if(domain.endsWith("." + root)) return true;
    }
    return false;
  }

  // Strictness mapping (0..100) -> gates
  function strictConfig(strictness){
    const s = Math.max(0, Math.min(100, Number(strictness || 0)));
    // At 0: always produce ideas, even low confidence
    // At 100: requires strong catalysts + decent average
    const minStrong = Math.round(0 + (2 - 0) * (s/100));
    const minAvg = 0.22 + (0.62 - 0.22) * (s/100);
    const liqFloor = 0.40 + (0.58 - 0.40) * (s/100);
    const etfBonus = 1.08 + (1.00 - 1.08) * (s/100); // slightly prefer ETFs at lenient
    return { s, minStrong, minAvg, liqFloor, etfBonus };
  }

  function updateStrictExplain(){
    const cfg = strictConfig(el.strictness.value);
    el.strictExplain.textContent =
      `${cfg.s} ⇒ minStrong=${cfg.minStrong}, minAvg=${round2(cfg.minAvg)}, liqFloor=${round2(cfg.liqFloor)}, ETFbonus=${round2(cfg.etfBonus)}`;
  }

  // Build GDELT query: KEEP SHORT (no domain list in query)
  function buildQueryFromTerms(terms, country){
    const core = "(" + terms.join(" OR ") + ")";
    let q = core + " sourcelang:english";
    if(country) q += ` sourcecountry:${country}`;
    return q.trim();
  }

  function buildGdeltUrl({ query, timespan, sort, maxrecords }){
    const url = new URL(GDELT_ENDPOINT);
    url.searchParams.set("query", query);
    url.searchParams.set("mode", "artlist");
    url.searchParams.set("format", "json");
    url.searchParams.set("timespan", timespan);
    url.searchParams.set("maxrecords", String(maxrecords));
    if(sort) url.searchParams.set("sort", sort);
    return url.toString();
  }

  // Concurrency-limited mapper
  async function mapLimit(items, limit, worker){
    const results = new Array(items.length);
    let i = 0;
    const runners = Array.from({length: Math.max(1, limit)}, async () => {
      while(i < items.length){
        const idx = i++;
        results[idx] = await worker(items[idx], idx);
      }
    });
    await Promise.all(runners);
    return results;
  }

  // Scoring
  function catalystClarity(title){
    const t = (title || "").toLowerCase();
    let score = 0.20;

    const hasNumber = /(\d+(\.\d+)?)|(%|\$|bps|basis points|million|billion|mbpd)/i.test(title || "");
    if(hasNumber) score += 0.18;

    const actionVerbs = [
      "announces","imposes","approves","ban","bans","halts","suspends","launches","strikes","attacks",
      "cuts","raises","hikes","slashes","warns","sanctions","tariff","export controls","ceasefire",
      "breach","ransomware","hack","exploit","zero-day","evacuation","earthquake","flood","wildfire"
    ];
    for(const w of actionVerbs){
      if(t.includes(w)) score += 0.03;
    }

    const specificityHints = ["opec","fed","ecb","boe","cpi","pce","brent","wti","pipeline","shipping lane","red sea","strait"];
    for(const w of specificityHints){
      if(t.includes(w)) score += 0.05;
    }

    const vague = ["what you need to know","explainer","analysis","opinion","why it matters","live updates"];
    for(const w of vague){
      if(t.includes(w)) score -= 0.05;
    }

    return clamp01(score);
  }

  function timingScore(seenDateUtc, nowUtc){
    if(!seenDateUtc || !(seenDateUtc instanceof Date) || isNaN(seenDateUtc)) return 0.55;
    const hours = Math.max(0, (nowUtc - seenDateUtc) / 36e5);
    const halfLifeHrs = 42;
    const score = Math.pow(0.5, hours / halfLifeHrs);
    return clamp01(0.15 + 0.85 * score);
  }

  function headlineTradeability({ topicKey, title, seenDate }, nowUtc){
    const clarity = catalystClarity(title);
    const timing = timingScore(seenDate, nowUtc);

    const sectorWeights = TOPIC_SECTOR_WEIGHTS[topicKey] || {};
    const sectors = Object.keys(sectorWeights);

    let liqAvg = 0, volAvg = 0, n = 0;
    for(const s of sectors){
      const tickers = TICKER_GROUPS[s] || [];
      for(const t of tickers){
        liqAvg += tickerLiquidity(t);
        volAvg += tickerVol(t);
        n++;
      }
    }
    liqAvg = n ? (liqAvg / n) : 0.55;
    volAvg = n ? (volAvg / n) : 0.55;

    const raw01 = clamp01(
      0.45 * clarity +
      0.25 * timing +
      0.15 * liqAvg +
      0.15 * volAvg
    );

    const score10 = Math.max(1, Math.min(10, Math.round(raw01 * 10)));
    const isStrong = (score10 >= 7) && (clarity >= 0.35);

    return { score10, raw01, clarity, timing, liqAvg, volAvg, isStrong };
  }

  function aggregateTickerScores(headlines, cfg){
    const tickerInfo = {};
    const tickerToGroup = {};
    for(const [g, arr] of Object.entries(TICKER_GROUPS)){
      for(const t of arr) tickerToGroup[t] = g;
    }
    function ensure(t){
      if(!tickerInfo[t]){
        const liq = tickerLiquidity(t);
        const vol = tickerVol(t);
        tickerInfo[t] = {
          ticker:t,
          group:tickerToGroup[t] || "unknown",
          isETF: isETF(t),
          liq, vol,
          score:0,
          drivers:[]
        };
      }
      return tickerInfo[t];
    }

    for(const h of headlines){
      const sectorWeights = TOPIC_SECTOR_WEIGHTS[h.topicKey] || {};
      for(const [sector, w] of Object.entries(sectorWeights)){
        const tickers = TICKER_GROUPS[sector] || [];
        for(const t of tickers){
          const info = ensure(t);

          // Liquidity floor gate (strictness)
          if(info.liq < cfg.liqFloor) continue;

          const lv = 0.55 * info.liq + 0.45 * info.vol;
          const etfBoost = info.isETF ? cfg.etfBonus : 1.0;

          const add = h.raw01 * w * lv * etfBoost;
          info.score += add;

          if(add > 0.03){
            info.drivers.push({
              add,
              topicKey: h.topicKey,
              title: h.title,
              url: h.url,
              seenDate: h.seenDate
            });
          }
        }
      }
    }

    const arr = Object.values(tickerInfo);
    const max = Math.max(0.0001, ...arr.map(x => x.score));
    for(const x of arr){
      x.scoreN = x.score / max;
      x.score100 = Math.round(x.scoreN * 100);
      x.drivers.sort((a,b)=>b.add-a.add);
      x.drivers = x.drivers.slice(0,4);
    }
    arr.sort((a,b)=>b.score-a.score);
    return arr;
  }

  // Fetch
  function parseGdeltSeenDate(s){
    if(!s) return null;
    const iso = String(s).replace(" ", "T") + "Z";
    const d = new Date(iso);
    return isNaN(d) ? null : d;
  }

  async function fetchTopic(topic, opts){
    const country = normalizeCountry(opts.country);

    // query computed upfront so it is visible even if request fails
    const query = (opts.customQuery && opts.customQuery.trim())
      ? (opts.customQuery.trim() + " sourcelang:english" + (country ? ` sourcecountry:${country}` : ""))
      : buildQueryFromTerms(topic.terms, country);

    // Pull a deeper pool so local domain filtering can still keep perTopic results
    const fetchMax = Math.max(opts.perTopic * 12, 60); // e.g. perTopic=5 => 60
    const url = buildGdeltUrl({
      query,
      timespan: opts.timespan,
      sort: opts.sort,
      maxrecords: fetchMax
    });

    const resp = await fetch(url);
    const text = await resp.text();

    let data;
    try { data = JSON.parse(text); }
    catch {
      throw new Error(`Non-JSON from GDELT (HTTP ${resp.status}): ${text.slice(0,180)}`);
    }

    const articles = Array.isArray(data) ? data : (data.articles || data.data || []);
    return { topicKey: topic.key, topicLabel: topic.label, query, url, articles };
  }

  // Render tabs
  function setActiveTab(tab){
    document.querySelectorAll(".tab").forEach(t=>{
      t.classList.toggle("active", t.dataset.tab === tab);
    });
    el.viewDecision.style.display = tab==="decision" ? "" : "none";
    el.viewHeadlines.style.display = tab==="headlines" ? "" : "none";
    el.viewTickers.style.display = tab==="tickers" ? "" : "none";
    el.viewDiag.style.display = tab==="diag" ? "" : "none";
    el.viewMethod.style.display = tab==="method" ? "" : "none";
  }

  function renderMethod(){
    el.viewMethod.innerHTML = `
      <div class="item">
        <div class="title">Why you were getting “HTTP 200 + error”</div>
        <div class="smallnote">
          GDELT often returns HTTP 200 with plain-text errors (not JSON). The most common cause is an overlong query.
          This build keeps the query short and applies trusted-domain filtering locally.
        </div>
      </div>

      <div class="item">
        <div class="title">Headline tradability score (1–10)</div>
        <div class="smallnote">
          Computed from four components (each 0..1): <b>Clarity</b> + <b>Timing</b> + <b>Liquidity</b> + <b>Volatility</b>.
          Strictness raises the gates (min strong catalysts + min average tradability + liquidity floor).
        </div>
        <div class="sub">
          <span class="badge"><span class="dot ok"></span><b>Clarity</b> title specificity (actions, numbers, key triggers)</span>
          <span class="badge"><span class="dot ok"></span><b>Timing</b> recency decay (half-life ~42 hours)</span>
          <span class="badge"><span class="dot ok"></span><b>Liquidity</b> heuristic per ticker</span>
          <span class="badge"><span class="dot ok"></span><b>Volatility</b> heuristic per ticker</span>
        </div>
      </div>

      <div class="item">
        <div class="title">Discipline layer (manual price)</div>
        <div class="smallnote">
          Enter a “current price”. The plan uses LIMIT entry (small pullback), fixed TP/SL rules, and computes fees ($8 per order) + 25% tax on gains.
        </div>
      </div>
    `;
  }

  // Discipline math
  function planFromPrice(ticker, price, capital){
    const etf = isETF(ticker);
    const entryPull = etf ? 0.003 : 0.007; // -0.3% ETFs, -0.7% stocks
    const tpPct = etf ? 0.15 : 0.225;      // ETFs +15%, stocks +22.5% (mid of 20–25)
    const slPct = etf ? 0.08 : 0.10;       // ETFs -8%, stocks -10
    const feePerOrder = 8;
    const taxRate = 0.25;

    const entry = price * (1 - entryPull);
    const tp = entry * (1 + tpPct);
    const sl = entry * (1 - slPct);

    const shares = Math.max(0, Math.floor(capital / entry));
    const cost = shares * entry;

    const feesRoundTrip = shares > 0 ? feePerOrder * 2 : 0;

    const grossTP = shares * (tp - entry);
    const pnlAfterFeesTP = grossTP - feesRoundTrip;
    const tax = Math.max(0, pnlAfterFeesTP) * taxRate;
    const netTP = pnlAfterFeesTP - tax;

    const grossSL = shares * (sl - entry); // negative
    const netSL = grossSL - feesRoundTrip; // fees worsen loss, no tax credit modeled

    const roiTP = shares > 0 ? (netTP / cost) : 0;
    const roiSL = shares > 0 ? (netSL / cost) : 0;

    const horizon = etf ? "15–20 trading days (time stop)" : "10–15 trading days (time stop)";
    return { etf, entryPull, tpPct, slPct, entry, tp, sl, shares, cost, feesRoundTrip, grossTP, pnlAfterFeesTP, tax, netTP, netSL, roiTP, roiSL, horizon };
  }

  // Render decision
  function renderDecision(scan){
    const tz = scan.opts.tz;
    const cfg = scan.cfg;

    const top = scan.topPicks || [];
    const decision = scan.decision;

    const kpis = `
      <div class="kpi">
        <span class="badge"><span class="dot ${scan.strongCount>0?'ok':'bad'}"></span><b>Strong catalysts:</b> ${scan.strongCount}</span>
        <span class="badge"><span class="dot ${scan.avgTrade>=cfg.minAvg?'ok':'warn'}"></span><b>Avg tradability:</b> ${round2(scan.avgTrade)}</span>
        <span class="badge"><span class="dot"></span><b>Raw:</b> ${scan.rawCount}</span>
        <span class="badge"><span class="dot"></span><b>After trusted filter:</b> ${scan.keptCount}</span>
        <span class="badge"><span class="dot"></span><b>Strictness:</b> ${cfg.s}</span>
      </div>
    `;

    if(decision === "NO TRADE"){
      el.viewDecision.innerHTML = `
        <div class="item">
          <div class="title">NO TRADE</div>
          ${kpis}
          <div class="smallnote">
            Gates not met: need <b>minStrong=${cfg.minStrong}</b> and <b>minAvg≥${round2(cfg.minAvg)}</b>.
            If you want ideas anyway, set Strictness to <b>0</b> (Idea Mode), or widen trusted sources / use Broad match.
          </div>
        </div>
      `;
      return;
    }

    const picksHtml = top.map((p, idx) => {
      const drivers = (p.drivers||[]).map(d=>{
        const when = d.seenDate ? fmtDate(new Date(d.seenDate), tz) : "";
        return `
          <div class="sub" style="margin-top:6px;">
            <span class="badge"><span class="dot ok"></span>+${round2(d.add)} driver</span>
            <span>${escapeHtml(d.topicKey)}</span>
            <a href="${escapeHtml(d.url)}" target="_blank" rel="noopener noreferrer">${escapeHtml(d.title)}</a>
            <span>${escapeHtml(when)}</span>
          </div>
        `;
      }).join("");

      return `
        <div class="item" data-pick="${escapeHtml(p.ticker)}">
          <div class="title">${idx+1}) ${escapeHtml(p.ticker)} <span class="badge">${escapeHtml(p.group)}</span> ${p.isETF?'<span class="badge">ETF</span>':'<span class="badge">Stock</span>'}</div>
          <div class="sub">
            <span class="badge"><b>Setup score:</b> ${p.score100}/100</span>
            <span class="badge"><b>Liq:</b> ${round2(p.liq)}</span>
            <span class="badge"><b>Vol:</b> ${round2(p.vol)}</span>
          </div>

          <div class="hr"></div>

          <div class="sub"><b>Discipline plan (manual price)</b></div>
          <div class="row3" style="margin-top:8px;">
            <div>
              <label style="margin-top:0;">Enter current price</label>
              <input type="number" step="0.01" min="0" placeholder="e.g. 142.50" class="priceInput" />
            </div>
            <div>
              <label style="margin-top:0;">Capital (USD)</label>
              <input type="number" step="50" min="1000" max="2000" value="1500" class="capInput" />
            </div>
            <div style="display:flex;align-items:flex-end;">
              <button class="primary calcBtn" style="height:42px;">Compute Plan</button>
            </div>
          </div>

          <div class="planOut smallnote"></div>

          <div class="hr"></div>

          <div class="smallnote"><b>Top drivers</b></div>
          ${drivers || `<div class="smallnote">No strong drivers stored (low add threshold).</div>`}
        </div>
      `;
    }).join("");

    el.viewDecision.innerHTML = `
      <div class="item">
        <div class="title">TRADE IDEAS</div>
        ${kpis}
        <div class="smallnote">
          Strictness=${cfg.s}. This is not a recommendation; it is a ranked “event sensitivity” output. Use the discipline plan and time stop.
        </div>
      </div>
      ${picksHtml}
    `;

    // attach calculators
    el.viewDecision.querySelectorAll(".item[data-pick]").forEach(card=>{
      const ticker = card.getAttribute("data-pick");
      const priceInput = card.querySelector(".priceInput");
      const capInput = card.querySelector(".capInput");
      const out = card.querySelector(".planOut");
      const btn = card.querySelector(".calcBtn");

      function compute(){
        const price = Number(priceInput.value || 0);
        const cap = Number(capInput.value || 0);
        if(!(price > 0) || !(cap >= 1000)){
          out.innerHTML = `<span class="danger">Enter a valid price (>0) and capital (≥1000).</span>`;
          return;
        }
        const plan = planFromPrice(ticker, price, cap);
        if(plan.shares <= 0){
          out.innerHTML = `<span class="warnText">Capital too small for 1 share at LIMIT entry (${round2(plan.entry)}). Increase capital or choose an ETF.</span>`;
          return;
        }

        out.innerHTML = `
          <div class="sub" style="margin-top:8px;">
            <span class="badge"><b>LIMIT entry:</b> ${round2(plan.entry)} (${plan.etf?'-0.3%':'-0.7%'} pullback)</span>
            <span class="badge"><b>TP:</b> ${round2(plan.tp)} (${plan.etf?'+15%':'+22.5%'} from entry)</span>
            <span class="badge"><b>SL:</b> ${round2(plan.sl)} (${plan.etf?'-8%':'-10%'} from entry)</span>
          </div>

          <div class="sub" style="margin-top:8px;">
            <span class="badge"><b>Shares:</b> ${plan.shares}</span>
            <span class="badge"><b>Capital used:</b> ${round2(plan.cost)}</span>
            <span class="badge"><b>Fees (entry+exit):</b> $${plan.feesRoundTrip}</span>
          </div>

          <div class="sub" style="margin-top:8px;">
            <span class="badge"><span class="dot ok"></span><b>Net @ TP:</b> $${round2(plan.netTP)} (ROI ${round2(plan.roiTP*100)}%)</span>
            <span class="badge"><span class="dot bad"></span><b>Net @ SL:</b> $${round2(plan.netSL)} (ROI ${round2(plan.roiSL*100)}%)</span>
            <span class="badge"><b>Tax @ TP:</b> $${round2(plan.tax)} (25% gains)</span>
          </div>

          <div class="smallnote" style="margin-top:8px;">
            <b>Time stop:</b> ${plan.horizon}. If TP/SL not hit by then, exit at market (discipline rule).
          </div>
        `;
      }

      btn.addEventListener("click", compute);
    });
  }

  function renderHeadlines(scan){
    const tz = scan.opts.tz;
    const allowlist = scan.allowlist;
    const mode = scan.opts.domainMode;

    const blocks = scan.byTopic.map(t=>{
      const meta = `
        <div class="smallnote">Query: <span class="mono">${escapeHtml(t.query)}</span></div>
        <div class="smallnote">GDELT: <a href="${escapeHtml(t.url)}" target="_blank" rel="noopener noreferrer">open results</a></div>
        <div class="smallnote">Trusted filter: ${allowlist.length ? `${allowlist.length} domains (${mode})` : "OFF"}</div>
      `;

      if(t.error){
        return `
          <div class="item">
            <div class="title">${escapeHtml(t.topicLabel)} <span class="badge">top 0</span></div>
            ${meta}
            <div class="item" style="border-color:rgba(255,128,128,.35); background:rgba(255,128,128,.06);">
              <div class="title">Error</div>
              <div class="smallnote">${escapeHtml(t.error)}</div>
            </div>
          </div>
        `;
      }

      const items = (t.items||[]).map(h=>{
        const when = h.seenDate ? fmtDate(new Date(h.seenDate), tz) : "";
        const dotClass = h.score10 >= 7 ? "ok" : (h.score10 <= 3 ? "bad" : "warn");
        return `
          <div class="item">
            <div class="title"><a href="${escapeHtml(h.url)}" target="_blank" rel="noopener noreferrer">${escapeHtml(h.title)}</a></div>
            <div class="sub">
              <span>${escapeHtml(h.domain||"")}</span>
              <span>${escapeHtml(when)}</span>
              <span class="badge"><span class="dot ${dotClass}"></span><b>Tradability:</b> ${h.score10}/10</span>
              <span class="badge"><b>Clarity:</b> ${round2(h.clarity)}</span>
              <span class="badge"><b>Timing:</b> ${round2(h.timing)}</span>
            </div>
          </div>
        `;
      }).join("");

      return `
        <div class="item">
          <div class="title">${escapeHtml(t.topicLabel)} <span class="badge">top ${t.items.length}</span></div>
          ${meta}
          ${t.filteredOut ? `<div class="smallnote warnText">Filtered out by trusted domains: ${t.filteredOut} articles</div>` : ""}
          <div style="margin-top:10px;" class="results">${items || `<div class="item">No results for this topic.</div>`}</div>
        </div>
      `;
    }).join("");

    el.viewHeadlines.innerHTML = blocks || `<div class="item">No headlines.</div>`;
  }

  function renderTickers(scan){
    const rows = (scan.tickerTable || []).slice(0, 50).map(x=>{
      return `
        <div class="item">
          <div class="title">${escapeHtml(x.ticker)} <span class="badge">${escapeHtml(x.group)}</span> ${x.isETF?'<span class="badge">ETF</span>':'<span class="badge">Stock</span>'}</div>
          <div class="sub">
            <span class="badge"><b>Score:</b> ${x.score100}/100</span>
            <span class="badge"><b>Liq:</b> ${round2(x.liq)}</span>
            <span class="badge"><b>Vol:</b> ${round2(x.vol)}</span>
          </div>
          ${x.drivers?.length ? `
            <div class="smallnote" style="margin-top:8px;">
              Drivers: ${x.drivers.map(d => `${escapeHtml(d.topicKey)} (+${round2(d.add)})`).join(", ")}
            </div>
          ` : `<div class="smallnote" style="margin-top:8px;">No strong drivers detected.</div>`}
        </div>
      `;
    }).join("");
    el.viewTickers.innerHTML = rows || `<div class="item">No ticker table.</div>`;
  }

  function renderDiag(scan){
    const allow = scan.allowlist.length ? `${scan.allowlist.length} domains (${scan.opts.domainMode})` : "OFF";
    el.viewDiag.innerHTML = `
      <div class="item">
        <div class="title">Diagnostics</div>
        <div class="smallnote mono">
          timespan=${scan.opts.timespan} | sort=${scan.opts.sort||"relevance"} | perTopic=${scan.opts.perTopic} | fetchDepth≈${Math.max(scan.opts.perTopic*12,60)} |
          sourcecountry=${escapeHtml(scan.opts.country||"—")} | trusted=${allow}
        </div>
        <div class="smallnote">
          <b>If you see 0 headlines:</b><br/>
          1) Set <b>Trusted preset</b> to Expanded + Broad match, or temporarily OFF.<br/>
          2) Increase lookback (1day/3day/1week).<br/>
          3) Leave custom query blank (bad custom queries can break results).
        </div>
      </div>

      <div class="item">
        <div class="title">Why XOP often appears</div>
        <div class="smallnote">
          You track multiple oil-linked topics (OPEC, oil, geopolitics, war, sanctions). Those map heavily to the energy sector weights.
          If energy headlines dominate the period, XOP (high vol ETF) will frequently rank high. This is expected behavior, not “hiding”.
        </div>
      </div>
    `;
  }

  function renderAll(scan){
    el.meta.textContent = `Scan @ ${fmtDate(new Date(scan.createdAt), scan.opts.tz)} | headlines: ${scan.keptCount} | decision: ${scan.decision}`;
    renderDecision(scan);
    renderHeadlines(scan);
    renderTickers(scan);
    renderDiag(scan);
    renderMethod();
  }

  // History
  function loadHistory(){
    const raw = localStorage.getItem(STORAGE_KEY);
    try{
      const arr = raw ? JSON.parse(raw) : [];
      return Array.isArray(arr) ? arr : [];
    }catch{ return []; }
  }
  function saveHistory(arr){
    localStorage.setItem(STORAGE_KEY, JSON.stringify(arr.slice(0, 30)));
  }
  function refreshHistoryDropdown(){
    const arr = loadHistory();
    el.history.innerHTML = "";
    const opt0 = document.createElement("option");
    opt0.value = "";
    opt0.textContent = "— Select saved scan —";
    el.history.appendChild(opt0);

    for(let i=0;i<arr.length;i++){
      const s = arr[i];
      const o = document.createElement("option");
      o.value = String(i);
      const dt = new Date(s.createdAt);
      const top = (s.topPicks || []).map(x=>x.ticker).join(", ");
      o.textContent = `${i+1}) ${dt.toLocaleString()} | Top: ${top || "—"}`;
      el.history.appendChild(o);
    }
  }

  // Export
  function exportJson(){
    if(!lastScan) return;
    const blob = new Blob([JSON.stringify(lastScan, null, 2)], { type:"application/json" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = `scan_${new Date(lastScan.createdAt).toISOString().replaceAll(":","-")}.json`;
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  }

  function saveCurrent(){
    if(!lastScan) return;
    const arr = loadHistory();
    arr.unshift(lastScan);
    saveHistory(arr);
    refreshHistoryDropdown();
    setStatus("Saved to History.");
  }
  function clearHistory(){
    localStorage.removeItem(STORAGE_KEY);
    refreshHistoryDropdown();
    setStatus("History cleared.");
  }
  function loadFromHistoryIndex(idx){
    const arr = loadHistory();
    const scan = arr[idx];
    if(!scan) return;
    lastScan = scan;
    setStatus("Loaded saved scan (no re-fetch).");
    renderAll(scan);
    el.saveBtn.disabled = false;
    el.exportBtn.disabled = false;
  }

  // Main run
  async function runScan(){
    setStatus("");
    el.runBtn.disabled = true;
    el.exportBtn.disabled = true;
    el.saveBtn.disabled = true;

    const nowUtc = new Date();
    const opts = {
      timespan: el.timespan.value,
      sort: el.sort.value,
      perTopic: Math.max(1, Math.min(25, Number(el.perTopic.value || 5))),
      concurrency: Math.max(1, Math.min(10, Number(el.concurrency.value || 4))),
      tz: el.tz.value || "Asia/Jerusalem",
      strictness: Math.max(0, Math.min(100, Number(el.strictness.value || 0))),
      country: normalizeCountry(el.country.value),
      trustedPreset: el.trustedPreset.value,
      domainMode: el.domainMode.value,
      customQuery: el.customQuery.value || ""
    };

    const cfg = strictConfig(opts.strictness);
    const allowlist = getAllowlist();

    setPills([
      ["timespan", opts.timespan],
      ["sort", opts.sort || "relevance"],
      ["perTopic", opts.perTopic],
      ["concurrency", opts.concurrency],
      ["sourcecountry", opts.country || "—"],
      ["trusted", (opts.trustedPreset==="off") ? "OFF" : `${allowlist.length} domains`],
      ["domainMode", opts.domainMode],
      ["strict", cfg.s]
    ]);

    setStatus("Fetching headlines from GDELT…");

    // Fetch each topic
    const byTopicRaw = await mapLimit(TOPICS, opts.concurrency, async (topic) => {
      try{
        const r = await fetchTopic(topic, opts);
        return { ...r, error:null };
      }catch(e){
        // Still show query if we can (fetchTopic throws after computing it, but it’s in message)
        return { topicKey: topic.key, topicLabel: topic.label, query:"", url:"", articles:[], error:String(e.message||e) };
      }
    });

    // Score + trusted filter locally
    let rawCount = 0;
    let keptCount = 0;
    let strongCount = 0;
    let sumTrade = 0;
    let tradeN = 0;

    const allHeadlines = [];
    const byTopic = byTopicRaw.map(t=>{
      if(t.error){
        return { topicKey:t.topicKey, topicLabel:t.topicLabel, query:t.query, url:t.url, error:t.error, filteredOut:0, items:[] };
      }

      const scored = (t.articles || []).map(a=>{
        const title = a.title || "(no title)";
        const url = a.url || a.url_mobile || "#";
        const domain = getDomainFromArticle(a);
        const seenDate = parseGdeltSeenDate(a.seendate || a.seenDate || "");

        const sc = headlineTradeability({ topicKey:t.topicKey, title, seenDate }, nowUtc);

        return {
          topicKey: t.topicKey,
          topicLabel: t.topicLabel,
          title, url, domain,
          seenDate: seenDate ? seenDate.toISOString() : null,
          score10: sc.score10,
          raw01: sc.raw01,
          clarity: sc.clarity,
          timing: sc.timing,
          isStrong: sc.isStrong
        };
      });

      rawCount += scored.length;

      // Apply trusted filter (if enabled)
      let filteredOut = 0;
      const kept = scored.filter(h=>{
        const ok = domainAllowed(h.domain, allowlist, opts.domainMode) || (opts.trustedPreset==="off");
        if(!ok) filteredOut++;
        return ok;
      });

      // Keep only top N by date order already from GDELT; slice to perTopic
      const items = kept.slice(0, opts.perTopic);

      // Collect stats + global list
      for(const h of items){
        keptCount++;
        sumTrade += h.raw01;
        tradeN++;
        if(h.isStrong) strongCount++;
        allHeadlines.push(h);
      }

      return { topicKey:t.topicKey, topicLabel:t.topicLabel, query:t.query, url:t.url, error:null, filteredOut, items };
    });

    const avgTrade = tradeN ? (sumTrade / tradeN) : 0;

    // Decide trade/no-trade:
    // - Strictness 0: always show ideas if any headlines exist
    // - Otherwise: gates apply
    let decision = "TRADE IDEAS";
    if(keptCount === 0){
      decision = "NO TRADE";
    } else if(cfg.s > 0){
      if(strongCount < cfg.minStrong || avgTrade < cfg.minAvg){
        decision = "NO TRADE";
      }
    }

    // Aggregate tickers
    const tickerTable = aggregateTickerScores(allHeadlines, cfg);
    const topPicks = tickerTable.slice(0, 3);

    const scan = {
      createdAt: nowUtc.toISOString(),
      opts,
      cfg,
      allowlist,
      rawCount,
      keptCount,
      strongCount,
      avgTrade: round4(avgTrade),
      decision,
      byTopic,
      tickerTable,
      topPicks
    };

    lastScan = scan;

    if(keptCount === 0){
      setStatus("0 headlines after trusted filtering. Try: Trusted preset OFF / Expanded + Broad, or increase lookback.", "warn");
    } else if(decision === "NO TRADE"){
      setStatus(`Completed: ${keptCount} headlines kept, but gates not met (strict=${cfg.s}).`, "warn");
    } else {
      setStatus(`Completed: ${keptCount} headlines kept.`, "");
    }

    renderAll(scan);

    el.runBtn.disabled = false;
    el.exportBtn.disabled = false;
    el.saveBtn.disabled = false;
  }

  // Events
  document.querySelectorAll(".tab").forEach(t=>{
    t.addEventListener("click", ()=> setActiveTab(t.dataset.tab));
  });

  el.runBtn.addEventListener("click", runScan);
  el.exportBtn.addEventListener("click", exportJson);
  el.saveBtn.addEventListener("click", saveCurrent);
  el.clearHistoryBtn.addEventListener("click", clearHistory);

  el.history.addEventListener("change", ()=>{
    const v = el.history.value;
    if(!v) return;
    loadFromHistoryIndex(Number(v));
  });

  el.strictness.addEventListener("input", ()=>{
    el.strictnessNum.value = el.strictness.value;
    updateStrictExplain();
  });
  el.strictnessNum.addEventListener("input", ()=>{
    el.strictness.value = el.strictnessNum.value;
    updateStrictExplain();
  });

  el.resetDomains.addEventListener("click", ()=>{
    applyPreset(el.trustedPreset.value === "off" ? "expanded" : el.trustedPreset.value);
    setStatus("Domains reset to preset.");
  });
  el.saveDomains.addEventListener("click", ()=>{
    saveDomains(el.domainList.value || "");
    setStatus("Domains list saved.");
  });

  el.trustedPreset.addEventListener("change", ()=>{
    if(el.trustedPreset.value === "off"){
      setStatus("Trusted domains filter OFF (will accept all English sources).", "warn");
      return;
    }
    applyPreset(el.trustedPreset.value);
    setStatus("Preset applied (you can edit and Save List).");
  });

  // Init
  el.domainList.value = loadDomains();
  refreshHistoryDropdown();
  updateStrictExplain();
  setActiveTab("decision");
  renderMethod();
})();
</script>
</body>
</html>
