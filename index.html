<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Event-Driven Trade Advisor (GDELT • English • Trusted Filter)</title>
  <style>
    :root{
      --bg:#0b0f17; --panel:#0e162a; --panel2:#0b1020;
      --border:#1d2a44; --border2:#233357;
      --text:#e8eefc; --muted:rgba(232,238,252,.72);
      --accent:#2a5cff; --bad:#ff8080; --ok:#93ffb4; --warn:#ffd27a;
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
    }
    body{margin:0;background:var(--bg);color:var(--text);}
    header{padding:18px 18px;border-bottom:1px solid var(--border);background:#0b1020;}
    header h1{margin:0 0 6px;font-size:18px;}
    header p{margin:0;color:var(--muted);font-size:13px;line-height:1.35;}
    main{padding:16px 18px;max-width:1260px;margin:0 auto;}
    .grid{display:grid;grid-template-columns:1fr;gap:12px;}
    @media(min-width:980px){.grid{grid-template-columns:470px 1fr;}}
    .card{background:var(--panel);border:1px solid var(--border);border-radius:14px;padding:14px;}
    label{display:block;font-size:12px;color:var(--muted);margin:10px 0 6px;}
    input,select,textarea,button{
      width:100%;box-sizing:border-box;border-radius:12px;border:1px solid var(--border2);
      background:var(--panel2);color:var(--text);padding:10px 11px;font-size:14px;
    }
    textarea{min-height:66px;resize:vertical;}
    .row{display:grid;grid-template-columns:1fr 1fr;gap:10px;}
    .row3{display:grid;grid-template-columns:1fr 1fr 1fr;gap:10px;}
    .actions{display:grid;grid-template-columns:1fr 1fr;gap:10px;margin-top:12px;}
    button{cursor:pointer;font-weight:800;}
    button.primary{background:var(--accent);border-color:var(--accent);}
    button.ghost{background:transparent;}
    button:disabled{opacity:.65;cursor:not-allowed;}
    .status{margin-top:10px;font-size:13px;color:var(--muted);}
    .status.error{color:var(--bad);}
    .pillbar{display:flex;flex-wrap:wrap;gap:8px;margin-top:10px;}
    .pill{border:1px solid var(--border2);background:var(--panel2);padding:5px 9px;border-radius:999px;font-size:12px;color:var(--muted);}
    .rightHead{display:flex;align-items:flex-end;justify-content:space-between;gap:12px;margin-bottom:10px;}
    .rightHead h2{margin:0;font-size:16px;}
    .rightHead .small{font-size:12px;color:var(--muted);text-align:right;}
    .tabs{display:flex;gap:8px;flex-wrap:wrap;margin:0 0 10px;}
    .tab{padding:8px 10px;border-radius:999px;border:1px solid var(--border2);background:var(--panel2);font-size:12px;color:var(--muted);cursor:pointer;user-select:none;}
    .tab.active{border-color:var(--accent);color:var(--text);}
    .results{display:grid;gap:10px;}
    .item{border-radius:14px;border:1px solid var(--border);background:var(--panel2);padding:12px;}
    .item .title{margin:0 0 6px;font-weight:900;line-height:1.25;}
    .item a{color:#9dc0ff;text-decoration:none;}
    .item a:hover{text-decoration:underline;}
    .sub{display:flex;gap:10px;flex-wrap:wrap;font-size:12px;color:var(--muted);align-items:center;}
    .badge{display:inline-flex;align-items:center;gap:6px;border:1px solid var(--border2);background:#0b1020;padding:4px 8px;border-radius:999px;}
    .dot{width:8px;height:8px;border-radius:999px;background:var(--muted);display:inline-block;}
    .dot.ok{background:var(--ok);}
    .dot.bad{background:var(--bad);}
    .dot.warn{background:var(--warn);}
    .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace;}
    .smallnote{font-size:12px;color:var(--muted);line-height:1.35;margin-top:10px;}
    .hr{height:1px;background:var(--border);margin:10px 0;}
    .kpi{display:grid;grid-template-columns:1fr 1fr;gap:10px;margin-top:8px;}
    .kpi .box{border:1px solid var(--border);background:#0b1020;border-radius:12px;padding:10px;}
    .kpi .box b{display:block;font-size:12px;margin-bottom:3px;}
    .kpi .box span{color:var(--muted);font-size:12px;}
    .bar{height:10px;border-radius:999px;background:#0b1020;border:1px solid var(--border2);overflow:hidden;}
    .bar > div{height:100%;background:var(--accent);width:0%;}
    .warnbox{border:1px solid rgba(255,210,122,.35);background:rgba(255,210,122,.07);}
    .okbox{border:1px solid rgba(147,255,180,.35);background:rgba(147,255,180,.07);}
    .badbox{border:1px solid rgba(255,128,128,.35);background:rgba(255,128,128,.07);}
    .compact{margin-top:6px;}
  </style>
</head>

<body>
<header>
  <h1>Event-Driven Trade Advisor <span class="badge"><span class="dot ok"></span>Free • English • Trusted Filter</span></h1>
  <p>
    Fetches GDELT DOC 2.0 (English-only) and filters results locally to an allowlist of trusted domains (avoids GDELT “query too long” errors).
    Generates a discipline trade plan using manual price input. Research tool only.
  </p>
</header>

<main class="grid">
  <!-- LEFT -->
  <section class="card">
    <div class="row">
      <div>
        <label>Lookback (TIMESPAN)</label>
        <select id="timespan">
          <option value="1h">Last 1 hour</option>
          <option value="6h">Last 6 hours</option>
          <option value="12h" selected>Last 12 hours</option>
          <option value="1day">Last 1 day</option>
          <option value="3day">Last 3 days</option>
          <option value="1week">Last 1 week</option>
        </select>
      </div>
      <div>
        <label>Sort</label>
        <select id="sort">
          <option value="datedesc" selected>Date (newest first)</option>
          <option value="">Relevance</option>
          <option value="toneasc">Tone (most negative)</option>
          <option value="tonedesc">Tone (most positive)</option>
        </select>
      </div>
    </div>

    <div class="row3">
      <div>
        <label>Headlines / topic (after filter)</label>
        <input id="perTopic" type="number" min="1" max="25" value="5" />
      </div>
      <div>
        <label>Concurrency</label>
        <input id="concurrency" type="number" min="1" max="10" value="4" />
      </div>
      <div>
        <label>Time zone display</label>
        <select id="tz">
          <option value="Asia/Jerusalem" selected>Asia/Jerusalem</option>
          <option value="UTC">UTC</option>
          <option value="America/New_York">America/New_York</option>
          <option value="Europe/London">Europe/London</option>
        </select>
      </div>
    </div>

    <label>Strictness (0 = Idea Mode, 100 = Strict)</label>
    <input id="strictness" type="range" min="0" max="100" value="70" />
    <div class="sub compact">
      <span class="badge"><span class="dot warn"></span><b>Mode:</b> <span id="modeLabel">Strict</span></span>
      <span class="badge"><b>Locked:</b> <span class="mono">sourcelang:english</span></span>
    </div>

    <label>Optional filter (applies to all topics)</label>
    <input id="country" placeholder="sourcecountry (e.g. unitedstates)" />

    <label>Trusted sources preset</label>
    <select id="domainPreset">
      <option value="expanded" selected>Expanded trusted (recommended)</option>
      <option value="core">Core wires + finance (stricter)</option>
      <option value="official">Official sources only (very strict)</option>
      <option value="custom">Custom allowlist (edit below)</option>
    </select>

    <label>Domain matching (local filter)</label>
    <select id="domainMatch">
      <option value="broad" selected>Broad match (recommended)</option>
      <option value="exact">Exact match</option>
    </select>

    <label>Oversample factor (fetch more before filtering)</label>
    <select id="oversample">
      <option value="4">x4</option>
      <option value="6" selected>x6</option>
      <option value="8">x8</option>
      <option value="10">x10</option>
    </select>
    <div class="smallnote">
      Because we filter locally, the app fetches more, then keeps only trusted domains.
    </div>

    <label>Trusted domains allowlist (FILTERED locally)</label>
    <textarea id="trustedDomains"></textarea>

    <div class="row">
      <button id="resetDomainsBtn" class="ghost">Reset to Preset</button>
      <button id="saveDomainsBtn" class="ghost">Save List</button>
    </div>

    <div class="smallnote">
      If you still get 0 headlines: increase Lookback (12h → 1day), raise Oversample (x6 → x10), or remove the country filter.
    </div>

    <label>Optional: custom topic query override (advanced)</label>
    <textarea id="customQuery" placeholder='Leave blank. Example: ("export controls" OR sanctions OR tariff)'></textarea>
    <div class="smallnote">
      This only replaces the topic terms. English-only stays enforced in the query.
    </div>

    <div class="actions">
      <button id="runBtn" class="primary">Run Scan</button>
      <button id="saveBtn" class="ghost" disabled>Save to History</button>
    </div>

    <div class="actions" style="grid-template-columns:1fr 1fr;">
      <button id="exportBtn" class="ghost" disabled>Export JSON</button>
      <button id="clearHistoryBtn" class="ghost">Clear History</button>
    </div>

    <div id="status" class="status"></div>
    <div id="pills" class="pillbar"></div>

    <div class="hr"></div>

    <label>Trade plan inputs (manual)</label>
    <div class="row">
      <div>
        <label>Capital per trade (USD)</label>
        <input id="capital" type="number" min="1000" max="2000" value="1500" />
      </div>
      <div>
        <label>Stock TP % (20–25)</label>
        <input id="stockTp" type="number" min="20" max="25" value="22" />
      </div>
    </div>
    <div class="smallnote">
      Fees: $8 per executed order. Tax: 25% on gains (simplified: no loss offsets). Limit orders + OCO plan.
    </div>

    <div class="hr"></div>

    <label>History (localStorage)</label>
    <select id="history"></select>
    <div class="smallnote">Load a saved scan without re-fetching.</div>
  </section>

  <!-- RIGHT -->
  <section class="card">
    <div class="rightHead">
      <h2>Results</h2>
      <div id="meta" class="small"></div>
    </div>

    <div class="tabs">
      <div class="tab active" data-tab="decision">Trade Decision</div>
      <div class="tab" data-tab="headlines">Headlines by Topic</div>
      <div class="tab" data-tab="tickers">Ticker Table</div>
      <div class="tab" data-tab="diagnostics">Diagnostics</div>
      <div class="tab" data-tab="method">Method</div>
    </div>

    <div id="viewDecision" class="results"></div>
    <div id="viewHeadlines" class="results" style="display:none;"></div>
    <div id="viewTickers" class="results" style="display:none;"></div>
    <div id="viewDiagnostics" class="results" style="display:none;"></div>
    <div id="viewMethod" class="results" style="display:none;"></div>
  </section>
</main>

<script>
(() => {
  const VERSION = "v8-local-domain-filter";
  const GDELT_ENDPOINT = "https://api.gdeltproject.org/api/v2/doc/doc";
  const LOCKED_SOURCELANG = "english";

  const PRESET_CORE = [
    "reuters.com","apnews.com","bloomberg.com","ft.com","wsj.com","cnbc.com",
    "economist.com","marketwatch.com","barrons.com"
  ];

  const PRESET_OFFICIAL = [
    "federalreserve.gov","ecb.europa.eu","bankofengland.co.uk","bls.gov","bea.gov",
    "opec.org","usgs.gov","noaa.gov","imf.org","worldbank.org"
  ];

  const PRESET_EXPANDED = [
    ...new Set([
      ...PRESET_CORE,
      "bbc.co.uk","theguardian.com","nytimes.com","washingtonpost.com",
      "aljazeera.com","dw.com","france24.com","npr.org",
      "defensenews.com","breakingdefense.com",
      ...PRESET_OFFICIAL
    ])
  ];

  const TICKER_GROUPS = {
    defense: ["PPA","ITA","LMT","NOC","GD","RTX","BA","HII","LHX","TDG","AVAV","KTOS"],
    cyber: ["CIBR","HACK","PANW","CRWD","FTNT","ZS","OKTA","NET"],
    semis: ["SMH","SOXX","NVDA","AVGO","TSM","MU","ASML","AMAT","LRCX","KLAC","AMD","ARM","MRVL"],
    energy: ["XLE","XOP","LNG","VLO","CVX","XOM","SLB","HAL","OIH"],
    shipping: ["INSW","STNG","TK","ZIM","DAC"],
    uranium: ["URNM","URA","CCJ","UEC","LEU"],
    water_agri: ["PHO","MOO","DBA","NTR","MOS","CF","DE"],
    insurers: ["KIE","CB","TRV","ALL","AIG"],
    gold: ["GLD","IAU","GDX"]
  };

  const ETF_SET = new Set([
    "PPA","ITA","CIBR","HACK","SMH","SOXX","XLE","XOP","OIH","KIE","URNM","URA","PHO","MOO","DBA","GLD","IAU","GDX"
  ]);

  const TOPICS = [
    { key:"geopolitics", label:"geopolitics", terms:['geopolitics','"regional tensions"','"border clash"','"military buildup"','"diplomatic crisis"'] },
    { key:"sanctions", label:"sanctions", terms:['sanctions','"export controls"','blacklist','"secondary sanctions"','"asset freeze"'] },
    { key:"ceasefire", label:"ceasefire", terms:['ceasefire','truce','"peace talks"','"temporary halt"'] },
    { key:"war", label:"war", terms:['war','airstrike','"missile attack"','"ground offensive"','"troop deployment"'] },
    { key:"regulation", label:"regulation", terms:['regulation','"regulatory crackdown"','antitrust','"compliance rule"','SEC','FTC'] },
    { key:"tariff", label:"tariff", terms:['tariff','"trade war"','"import duty"','"export ban"'] },
    { key:"cyber", label:"cyber", terms:['cyber','ransomware','"data breach"','DDoS','"zero-day"','hackers'] },
    { key:"earthquake", label:"earthquake", terms:['earthquake','seismic','aftershock','magnitude'] },
    { key:"flood", label:"flood", terms:['flood','"flash flood"','"storm surge"','"river overflow"'] },
    { key:"wildfire", label:"wildfire", terms:['wildfire','"forest fire"','"evacuation order"','burning'] },
    { key:"inflation", label:"inflation", terms:['inflation','CPI','PCE','"price pressures"','"core inflation"'] },
    { key:"rates", label:"rates", terms:['"interest rate"','"rate hike"','"rate cut"','"policy rate"','"Federal Reserve"','ECB','BoE'] },
    { key:"recession", label:"recession", terms:['recession','"GDP contraction"','"yield curve"','"job losses"','"hard landing"'] },
    { key:"OPEC", label:"OPEC", terms:['OPEC','"OPEC+"','"oil output"','"production cut"','quota'] },
    { key:"oil", label:"oil", terms:['"crude oil"','Brent','WTI','"oil prices"','"oil supply"'] }
  ];

  const TOPIC_SECTOR_WEIGHTS = {
    geopolitics: { defense:0.8, energy:0.6, shipping:0.5, gold:0.6, insurers:0.2 },
    sanctions:   { energy:0.5, shipping:0.5, defense:0.4, semis:0.25, gold:0.3 },
    ceasefire:   { shipping:0.6, energy:0.25, gold:0.15, defense:0.15 },
    war:         { defense:0.9, energy:0.6, gold:0.7, shipping:0.4 },
    regulation:  { insurers:0.35, semis:0.25, energy:0.2 },
    tariff:      { semis:0.45, shipping:0.35, energy:0.2 },
    cyber:       { cyber:0.95 },
    earthquake:  { insurers:0.25, water_agri:0.25, energy:0.15 },
    flood:       { insurers:0.25, water_agri:0.35, energy:0.15 },
    wildfire:    { insurers:0.25, water_agri:0.35, energy:0.15 },
    inflation:   { gold:0.35, insurers:0.25, energy:0.2 },
    rates:       { insurers:0.35, gold:0.25 },
    recession:   { gold:0.45, insurers:0.25 },
    OPEC:        { energy:0.9, shipping:0.35 },
    oil:         { energy:0.85, shipping:0.3 }
  };

  const LIQ = Object.fromEntries([
    ["PPA",0.75],["ITA",0.8],["CIBR",0.8],["HACK",0.7],["SMH",0.85],["SOXX",0.85],
    ["XLE",0.9],["XOP",0.75],["OIH",0.6],["KIE",0.65],["URNM",0.55],["URA",0.65],
    ["PHO",0.55],["MOO",0.55],["DBA",0.6],["GLD",0.95],["IAU",0.85],["GDX",0.75],
    ["NVDA",0.95],["AVGO",0.9],["TSM",0.9],["AMD",0.9],["XOM",0.9],["CVX",0.85],
    ["BA",0.85],["RTX",0.8],["LMT",0.75],["PANW",0.8],["CRWD",0.8],["NET",0.75],
    ["AVAV",0.55],["KTOS",0.5],["HII",0.45],["INSW",0.45],["STNG",0.5],["TK",0.4],
    ["ZIM",0.6],["DAC",0.45],["UEC",0.45],["LEU",0.45]
  ]);

  const VOL = Object.fromEntries([
    ["NVDA",0.9],["AMD",0.85],["ARM",0.85],["MRVL",0.8],["MU",0.85],
    ["XOP",0.8],["OIH",0.85],["HAL",0.75],["SLB",0.7],
    ["ZIM",0.9],["STNG",0.75],["INSW",0.6],
    ["CRWD",0.8],["PANW",0.65],["NET",0.75],["FTNT",0.65],
    ["GLD",0.35],["GDX",0.6],["IAU",0.3],
    ["LMT",0.35],["NOC",0.35],["RTX",0.4],["BA",0.6],["KTOS",0.7],["AVAV",0.65],
    ["KIE",0.35],["AIG",0.45],["ALL",0.35]
  ]);

  const DEFAULT_LIQ = 0.55;
  const DEFAULT_VOL = 0.55;

  const RUNTIME = {
    strictness: 0.70,
    ideaMode: false,
    minAvgTrade01: 0.40,
    minKept: 10,
    strongScoreCut: 6,
    strongClarityCut: 0.45,
    requireStrong: true
  };

  const el = {
    timespan: document.getElementById("timespan"),
    sort: document.getElementById("sort"),
    perTopic: document.getElementById("perTopic"),
    concurrency: document.getElementById("concurrency"),
    tz: document.getElementById("tz"),
    strictness: document.getElementById("strictness"),
    modeLabel: document.getElementById("modeLabel"),
    country: document.getElementById("country"),
    domainPreset: document.getElementById("domainPreset"),
    domainMatch: document.getElementById("domainMatch"),
    oversample: document.getElementById("oversample"),
    trustedDomains: document.getElementById("trustedDomains"),
    resetDomainsBtn: document.getElementById("resetDomainsBtn"),
    saveDomainsBtn: document.getElementById("saveDomainsBtn"),
    customQuery: document.getElementById("customQuery"),
    capital: document.getElementById("capital"),
    stockTp: document.getElementById("stockTp"),
    runBtn: document.getElementById("runBtn"),
    saveBtn: document.getElementById("saveBtn"),
    exportBtn: document.getElementById("exportBtn"),
    clearHistoryBtn: document.getElementById("clearHistoryBtn"),
    status: document.getElementById("status"),
    pills: document.getElementById("pills"),
    meta: document.getElementById("meta"),
    history: document.getElementById("history"),
    viewDecision: document.getElementById("viewDecision"),
    viewHeadlines: document.getElementById("viewHeadlines"),
    viewTickers: document.getElementById("viewTickers"),
    viewDiagnostics: document.getElementById("viewDiagnostics"),
    viewMethod: document.getElementById("viewMethod"),
  };

  let lastScan = null;

  const clamp01 = (x) => Math.max(0, Math.min(1, x));
  const round2 = (x) => Math.round(x * 100) / 100;
  const round4 = (x) => Math.round(x * 10000) / 10000;

  function setStatus(msg, isError=false){
    el.status.textContent = msg || "";
    el.status.className = "status" + (isError ? " error" : "");
  }

  function setPills(pairs){
    el.pills.innerHTML = "";
    for(const [k,v] of pairs){
      const d = document.createElement("div");
      d.className = "pill";
      d.textContent = `${k}: ${v}`;
      el.pills.appendChild(d);
    }
  }

  function escapeHtml(s){
    return String(s ?? "")
      .replaceAll("&","&amp;").replaceAll("<","&lt;").replaceAll(">","&gt;")
      .replaceAll('"',"&quot;").replaceAll("'","&#039;");
  }

  function fmtDate(dt, tz){
    try{
      return new Intl.DateTimeFormat(undefined, {
        timeZone: tz, year:"numeric", month:"2-digit", day:"2-digit",
        hour:"2-digit", minute:"2-digit", second:"2-digit"
      }).format(dt);
    }catch{
      return dt.toISOString();
    }
  }

  function normalizeDomain(d){
    return String(d || "")
      .trim()
      .toLowerCase()
      .replace(/^https?:\/\//, "")
      .replace(/\/.*$/, "")
      .replace(/^\./, "")
      .replace(/\s+/g, "");
  }

  function parseDomains(text){
    return String(text || "")
      .split(/[\n,;]+/g)
      .map(x => normalizeDomain(x))
      .filter(Boolean)
      .filter(x => x.includes("."));
  }

  function getPresetDomains(preset){
    if(preset === "core") return PRESET_CORE.slice();
    if(preset === "official") return PRESET_OFFICIAL.slice();
    return PRESET_EXPANDED.slice();
  }

  function buildGdeltUrl({ query, timespan, sort, maxrecords }){
    const url = new URL(GDELT_ENDPOINT);
    url.searchParams.set("query", query);
    url.searchParams.set("mode", "artlist");
    url.searchParams.set("format", "json");
    url.searchParams.set("timespan", timespan);
    url.searchParams.set("maxrecords", String(maxrecords));
    if(sort) url.searchParams.set("sort", sort);
    return url.toString();
  }

  async function mapLimit(items, limit, worker){
    const results = new Array(items.length);
    let i = 0;
    const runners = Array.from({length: Math.max(1, limit)}, async () => {
      while(i < items.length){
        const idx = i++;
        results[idx] = await worker(items[idx], idx);
      }
    });
    await Promise.all(runners);
    return results;
  }

  function parseGdeltSeenDate(s){
    if(!s) return null;
    const iso = String(s).replace(" ", "T") + "Z";
    const d = new Date(iso);
    return isNaN(d) ? null : d;
  }

  function applyStrictnessFromUI(){
    const sPct = Math.max(0, Math.min(100, Number(el.strictness.value || 70)));
    const s = sPct / 100;

    RUNTIME.strictness = s;
    RUNTIME.ideaMode = (s <= 0.05);
    RUNTIME.minAvgTrade01 = RUNTIME.ideaMode ? 0 : (0.18 + s * (0.45 - 0.18));
    RUNTIME.minKept = RUNTIME.ideaMode ? 1 : Math.round(6 + s * 10);
    RUNTIME.strongScoreCut   = RUNTIME.ideaMode ? 4 : (s >= 0.70 ? 6 : (s >= 0.45 ? 5 : 4));
    RUNTIME.strongClarityCut = RUNTIME.ideaMode ? 0.30 : (s >= 0.70 ? 0.45 : (s >= 0.45 ? 0.38 : 0.30));
    RUNTIME.requireStrong = !RUNTIME.ideaMode && (s >= 0.40);

    el.modeLabel.textContent = RUNTIME.ideaMode ? "Idea Mode" : (s >= 0.75 ? "Strict" : (s >= 0.45 ? "Balanced" : "Lenient"));
  }

  function tickerLiquidity(t){ return LIQ[t] ?? DEFAULT_LIQ; }
  function tickerVol(t){ return VOL[t] ?? DEFAULT_VOL; }
  function getInstrumentType(t){ return ETF_SET.has(t) ? "ETF" : "Stock"; }

  function isSoftHeadline(title){
    const t = (title || "").toLowerCase();
    const soft = ["what you need to know","explainer","analysis","opinion","why it matters","live updates","timeline","explained"];
    return soft.some(w => t.includes(w));
  }

  function catalystClarity(title){
    const t = (title || "").toLowerCase();
    let score = 0.18;
    const hasNumber = /(\d+(\.\d+)?)|(%|\$|bps|basis points|million|billion|mbpd)/i.test(title || "");
    if(hasNumber) score += 0.18;

    const actionVerbs = [
      "announces","imposes","approves","ban","bans","halts","suspends","launches","strikes","attacks",
      "cuts","raises","hikes","slashes","warns","sanctions","tariff","export controls","ceasefire",
      "breach","ransomware","hack","exploit","zero-day","evacuation","earthquake","flood","wildfire"
    ];
    for(const w of actionVerbs){
      if(t.includes(w)) score += 0.03;
    }

    const specificityHints = ["opec","fed","ecb","boe","cpi","pce","brent","wti","pipeline","shipping lane","red sea","strait","export controls","tariffs"];
    for(const w of specificityHints){
      if(t.includes(w)) score += 0.05;
    }

    const vague = ["what you need to know","explainer","analysis","opinion","why it matters","live updates"];
    for(const w of vague){
      if(t.includes(w)) score -= 0.05;
    }
    return clamp01(score);
  }

  function timingScore(seenDateUtc, nowUtc){
    if(!seenDateUtc || !(seenDateUtc instanceof Date) || isNaN(seenDateUtc)) return 0.55;
    const hours = Math.max(0, (nowUtc - seenDateUtc) / 36e5);
    const halfLifeHrs = 48;
    const score = Math.pow(0.5, hours / halfLifeHrs);
    return clamp01(0.15 + 0.85 * score);
  }

  function headlineImpactScore({ topicKey, title, seenDate }, nowUtc){
    const clarity = catalystClarity(title);
    const timing = timingScore(seenDate, nowUtc);

    const sectorWeights = TOPIC_SECTOR_WEIGHTS[topicKey] || {};
    const sectors = Object.keys(sectorWeights);

    let liqAvg = 0, volAvg = 0, n = 0;
    for(const s of sectors){
      const tickers = TICKER_GROUPS[s] || [];
      for(const t of tickers){
        liqAvg += tickerLiquidity(t);
        volAvg += tickerVol(t);
        n++;
      }
    }
    liqAvg = n ? (liqAvg / n) : 0.55;
    volAvg = n ? (volAvg / n) : 0.55;

    const raw = clamp01(0.45 * clarity + 0.25 * timing + 0.15 * liqAvg + 0.15 * volAvg);
    const score10 = Math.max(1, Math.min(10, Math.round(raw * 10)));
    const trade01 = clamp01(score10 / 10);
    return { score10, trade01, clarity, timing };
  }

  function isCatalystHeadline(h){
    if(!h) return false;
    if(h.soft) return false;
    return (h.clarity >= 0.28 && h.timing >= 0.25);
  }

  function computeDecisionMetrics(allHeadlines){
    const kept = allHeadlines.filter(isCatalystHeadline);
    const keptSorted = [...kept].sort((a,b)=>b.trade01-a.trade01);

    const K = Math.max(5, Math.min(15, Math.round(keptSorted.length * 0.25) || 5));
    const topK = keptSorted.slice(0, K);
    const avgTopK = topK.length ? (topK.reduce((s,x)=>s + x.trade01, 0) / topK.length) : 0;

    const strong = kept.filter(h => (h.score10 >= RUNTIME.strongScoreCut) && (h.clarity >= RUNTIME.strongClarityCut));

    let decision = "NO TRADE";
    const reasons = [];

    if(RUNTIME.ideaMode){
      decision = "IDEA MODE";
      reasons.push("Strictness ~0: showing candidates even if strict discipline gates fail.");
      return { kept, strong, avgTopK, K, decision, reasons };
    }

    if(kept.length < RUNTIME.minKept) reasons.push(`Not enough catalyst headlines (kept ${kept.length} < min ${RUNTIME.minKept}).`);
    if(RUNTIME.requireStrong && strong.length < 1) reasons.push(`No strong catalysts (need ≥1 at score≥${RUNTIME.strongScoreCut} & clarity≥${RUNTIME.strongClarityCut}).`);
    if(avgTopK < RUNTIME.minAvgTrade01) reasons.push(`Average tradability too low (avgTopK ${round2(avgTopK)} < min ${round2(RUNTIME.minAvgTrade01)}).`);

    if(reasons.length === 0){
      decision = "TRADE";
      reasons.push("Catalyst density and tradability meet discipline gates.");
    }
    return { kept, strong, avgTopK, K, decision, reasons };
  }

  function aggregateTickerScores(headlines){
    const tickerInfo = {};
    const tickerToGroup = {};
    for(const [g, arr] of Object.entries(TICKER_GROUPS)){
      for(const t of arr) tickerToGroup[t] = g;
    }
    const groupContrib = Object.fromEntries(Object.keys(TICKER_GROUPS).map(g => [g, 0]));

    function ensure(t){
      if(!tickerInfo[t]){
        tickerInfo[t] = { ticker:t, group:tickerToGroup[t] || "unknown", liq:tickerLiquidity(t), vol:tickerVol(t), score:0, drivers:[] };
      }
      return tickerInfo[t];
    }

    for(const h of headlines){
      const sectorWeights = TOPIC_SECTOR_WEIGHTS[h.topicKey] || {};
      const base = h.trade01;

      for(const [sector, w] of Object.entries(sectorWeights)){
        const tickers = TICKER_GROUPS[sector] || [];
        for(const t of tickers){
          const info = ensure(t);
          const lv = 0.55 * info.liq + 0.45 * info.vol;
          const add = base * w * lv;
          info.score += add;
          groupContrib[sector] = (groupContrib[sector] || 0) + Math.max(0, add);
          if(add > 0.030){
            info.drivers.push({ add, topicKey: h.topicKey, title: h.title, url: h.url, seenDate: h.seenDate });
          }
        }
      }
    }

    const arr = Object.values(tickerInfo);
    const max = Math.max(0.000001, ...arr.map(x => x.score));
    for(const x of arr){
      x.scoreN = x.score / max;
      x.score100 = Math.round(x.scoreN * 100);
      x.drivers.sort((a,b)=>b.add-a.add);
      x.drivers = x.drivers.slice(0,4);
    }
    arr.sort((a,b)=>b.score-a.score);

    const totalGroup = Object.values(groupContrib).reduce((a,b)=>a+b, 0.000001);
    const groupShares = Object.entries(groupContrib)
      .map(([g,v]) => ({ group:g, value:v, share:v/totalGroup }))
      .sort((a,b)=>b.value-a.value);

    return { tickerTable: arr, groupShares };
  }

  function computeTradePlan({ ticker, instrumentType, manualPrice, capitalUsd, stockTpPct }){
    const price = Number(manualPrice);
    const cap = Number(capitalUsd);
    if(!isFinite(price) || price <= 0) return { ok:false, error:"Enter a valid current price." };
    if(!isFinite(cap) || cap <= 0) return { ok:false, error:"Enter a valid capital amount." };

    const isETF = (instrumentType === "ETF");
    const pullback = isETF ? 0.003 : 0.007;
    const entry = price * (1 - pullback);

    const tpPct = isETF ? 0.15 : Math.max(0.20, Math.min(0.25, Number(stockTpPct)/100));
    const slPct = isETF ? -0.08 : -0.10;

    const tp = entry * (1 + tpPct);
    const slStop = entry * (1 + slPct);

    const stopLimitBuffer = isETF ? 0.003 : 0.005;
    const slLimit = slStop * (1 - stopLimitBuffer);

    const shares = Math.floor(cap / entry);
    if(shares < 1) return { ok:false, error:`Capital too small for 1 share at entry ~$${round2(entry)}.` };

    const notional = shares * entry;
    const feePerOrder = 8;
    const fees = feePerOrder * 2;
    const taxRate = 0.25;

    const grossTp = shares * (tp - entry);
    const netBeforeTaxTp = grossTp - fees;
    const taxTp = Math.max(0, netBeforeTaxTp) * taxRate;
    const netAfterTaxTp = netBeforeTaxTp - taxTp;

    const grossSl = shares * (slStop - entry);
    const netAfterTaxSl = grossSl - fees;

    return {
      ok:true, shares, instrumentType,
      entry: round2(entry), tp: round2(tp),
      slStop: round2(slStop), slLimit: round2(slLimit),
      notional: round2(notional), fees: round2(fees), taxRate,
      tpStats: { gross: round2(grossTp), tax: round2(taxTp), netAfterTax: round2(netAfterTaxTp) },
      slStats: { gross: round2(grossSl), netAfterTax: round2(netAfterTaxSl) },
      timeStop: isETF ? "15–20 trading days" : "10–15 trading days"
    };
  }

  function buildFinalQuery(core, opts){
    let q = core;
    q += ` sourcelang:${LOCKED_SOURCELANG}`;
    if(opts.country) q += ` sourcecountry:${opts.country}`;
    return q.trim();
  }

  function buildQueryFromTerms(terms, opts){
    const core = "(" + terms.join(" OR ") + ")";
    return buildFinalQuery(core, opts);
  }

  function buildQueryFromCustom(custom, opts){
    const core = "(" + custom.trim() + ")";
    return buildFinalQuery(core, opts);
  }

  async function fetchTopic(topic, opts){
    const query = (opts.customQuery && opts.customQuery.trim())
      ? buildQueryFromCustom(opts.customQuery, opts)
      : buildQueryFromTerms(topic.terms, opts);

    const url = buildGdeltUrl({ query, timespan: opts.timespan, sort: opts.sort, maxrecords: opts.maxrecords });
    const resp = await fetch(url);
    const text = await resp.text();

    let data;
    try { data = JSON.parse(text); }
    catch { throw new Error(`Non-JSON from GDELT (HTTP ${resp.status}): ${text.slice(0,200)}`); }

    const articles = Array.isArray(data) ? data : (data.articles || data.data || []);
    return { topicKey: topic.key, topicLabel: topic.label, query, url, articles };
  }

  function domainAllowed(articleDomain, allowlist, matchMode){
    const d = normalizeDomain(articleDomain);
    if(!d) return false;

    if(matchMode === "exact"){
      // exact: d must be exactly allowlist entry (or www variant)
      return allowlist.includes(d) || (d.startsWith("www.") && allowlist.includes(d.slice(4)));
    }

    // broad: allow if d endsWith allowlist domain (handles subdomains)
    for(const dom of allowlist){
      if(d === dom) return true;
      if(d.endsWith("." + dom)) return true;
      if(dom.startsWith("www.") && (d === dom.slice(4) || d.endsWith("." + dom.slice(4)))) return true;
    }
    return false;
  }

  function setActiveTab(tab){
    document.querySelectorAll(".tab").forEach(t=>t.classList.toggle("active", t.dataset.tab === tab));
    el.viewDecision.style.display = tab==="decision" ? "" : "none";
    el.viewHeadlines.style.display = tab==="headlines" ? "" : "none";
    el.viewTickers.style.display = tab==="tickers" ? "" : "none";
    el.viewDiagnostics.style.display = tab==="diagnostics" ? "" : "none";
    el.viewMethod.style.display = tab==="method" ? "" : "none";
  }

  function renderMethod(){
    el.viewMethod.innerHTML = `
      <div class="item">
        <div class="title">Why your previous build broke</div>
        <div class="smallnote">
          Embedding many domains inside the GDELT query can exceed GDELT's query-length limits.
          This build avoids that by filtering domains locally after fetching English-only headlines.
        </div>
      </div>
      <div class="item">
        <div class="title">How “trusted only” is enforced</div>
        <div class="smallnote">
          We fetch from GDELT, then discard any article whose domain is not in your allowlist.
          “Oversample” controls how many we fetch before filtering.
        </div>
      </div>
    `;
  }

  function renderHeadlines(scan){
    const tz = scan.opts.tz;

    const blocks = scan.byTopic.map(t => {
      const items = (t.items || []).map(h => {
        const when = h.seenDate ? fmtDate(new Date(h.seenDate), tz) : "";
        const dotClass = h.score10 >= 7 ? "ok" : (h.score10 <= 3 ? "bad" : "warn");
        const softTag = h.soft ? `<span class="badge"><span class="dot warn"></span>soft</span>` : "";
        return `
          <div class="item">
            <div class="title">
              <a href="${escapeHtml(h.url)}" target="_blank" rel="noopener noreferrer">${escapeHtml(h.title)}</a>
            </div>
            <div class="sub">
              <span>${escapeHtml(h.domain || "")}</span>
              <span>${escapeHtml(when)}</span>
              <span class="badge"><span class="dot ${dotClass}"></span><b>Impact:</b> ${h.score10}/10</span>
              <span class="badge"><b>Clarity:</b> ${round2(h.clarity)}</span>
              <span class="badge"><b>Timing:</b> ${round2(h.timing)}</span>
              ${softTag}
            </div>
            <div class="smallnote mono" style="margin-top:8px; word-break:break-word;">${escapeHtml(h.url)}</div>
          </div>
        `;
      }).join("");

      const err = t.error ? `<div class="item badbox"><div class="title">Error</div><div class="smallnote">${escapeHtml(t.error)}</div></div>` : "";
      const counts = `
        <div class="sub" style="margin-top:6px;">
          <span class="badge"><b>Fetched:</b> ${t.fetchedCount}</span>
          <span class="badge"><b>Trusted-kept:</b> ${t.trustedKept}</span>
          <span class="badge"><b>Dropped:</b> ${t.droppedUntrusted}</span>
        </div>
      `;

      return `
        <div class="item">
          <div class="title">${escapeHtml(t.topicLabel)} <span class="badge">top ${t.items.length}</span></div>
          <div class="smallnote">Query: <span class="mono">${escapeHtml(t.query)}</span></div>
          <div class="smallnote">GDELT: <a href="${escapeHtml(t.url)}" target="_blank" rel="noopener noreferrer">open results</a></div>
          ${counts}
          ${err}
          <div style="margin-top:10px;" class="results">${items || `<div class="item warnbox">No trusted results for this topic.</div>`}</div>
        </div>
      `;
    }).join("");

    el.viewHeadlines.innerHTML = blocks || `<div class="item">No headlines.</div>`;
  }

  function renderTickers(scan){
    const rows = (scan.tickerTable || []).slice(0, 40).map(x => {
      const itype = getInstrumentType(x.ticker);
      return `
        <div class="item">
          <div class="title">${escapeHtml(x.ticker)} <span class="badge">${escapeHtml(x.group)}</span> <span class="badge">${itype}</span></div>
          <div class="sub">
            <span class="badge"><b>Score:</b> ${x.score100}/100</span>
            <span class="badge"><b>Liq:</b> ${round2(x.liq)}</span>
            <span class="badge"><b>Vol:</b> ${round2(x.vol)}</span>
          </div>
          ${x.drivers?.length ? `
            <div class="smallnote" style="margin-top:8px;">
              Drivers: ${x.drivers.map(d => `${escapeHtml(d.topicKey)} (+${round2(d.add)})`).join(", ")}
            </div>
          ` : `<div class="smallnote" style="margin-top:8px;">No strong drivers detected.</div>`}
        </div>
      `;
    }).join("");
    el.viewTickers.innerHTML = rows || `<div class="item">No ticker table.</div>`;
  }

  function renderDiagnostics(scan){
    const gs = scan.groupShares || [];
    const top3 = gs.slice(0,3);

    const note = top3.length ? `
      <div class="item warnbox">
        <div class="title">Sector dominance</div>
        <div class="smallnote">
          Top contributing groups: <b>${escapeHtml(top3.map(x => `${x.group} (${Math.round(x.share*100)}%)`).join(", "))}</b>.
          If Energy dominates, XOP/XLE-style picks repeating can be legitimate.
        </div>
      </div>
    ` : "";

    const bars = gs.map(g => {
      const pct = Math.round(g.share * 100);
      return `
        <div class="item">
          <div class="title">${escapeHtml(g.group)}</div>
          <div class="sub">
            <span class="badge"><b>Share:</b> ${pct}%</span>
            <span class="badge"><b>Contribution:</b> ${round4(g.value)}</span>
          </div>
          <div class="bar" style="margin-top:10px;"><div style="width:${pct}%;"></div></div>
        </div>
      `;
    }).join("");

    const filterStats = `
      <div class="item">
        <div class="title">Trusted filter stats</div>
        <div class="smallnote">
          Raw fetched: <b>${scan.rawFetched}</b> • Trusted kept: <b>${scan.trustedKeptTotal}</b> • Dropped untrusted: <b>${scan.droppedUntrustedTotal}</b>
        </div>
      </div>
    `;

    el.viewDiagnostics.innerHTML = note + filterStats + (bars || `<div class="item">No diagnostics available.</div>`);
  }

  function renderDecision(scan){
    const tz = scan.opts.tz;
    const dec = scan.decisionMetrics;

    const decisionBadge = dec.decision === "TRADE"
      ? `<span class="badge"><span class="dot ok"></span><b>TRADE</b></span>`
      : (dec.decision === "IDEA MODE"
        ? `<span class="badge"><span class="dot warn"></span><b>IDEA MODE</b></span>`
        : `<span class="badge"><span class="dot bad"></span><b>NO TRADE</b></span>`);

    const reasons = dec.reasons.map(r => `<div class="smallnote">• ${escapeHtml(r)}</div>`).join("");

    const header = `
      <div class="item ${dec.decision==="TRADE" ? "okbox" : (dec.decision==="IDEA MODE" ? "warnbox" : "badbox")}">
        <div class="title">Decision ${decisionBadge}</div>
        <div class="sub">
          <span class="badge"><b>Strictness:</b> ${Math.round(RUNTIME.strictness*100)}%</span>
          <span class="badge"><b>Oversample:</b> x${escapeHtml(scan.opts.oversample)}</span>
          <span class="badge"><b>Trusted domains:</b> ${scan.opts.trustedDomains.length}</span>
          <span class="badge"><b>Version:</b> ${escapeHtml(VERSION)}</span>
        </div>
        <div class="kpi">
          <div class="box"><b>trusted headlines</b><span>${scan.countHeadlines}</span></div>
          <div class="box"><b>kept (catalysts)</b><span>${dec.kept.length} (min ${RUNTIME.minKept})</span></div>
          <div class="box"><b>strong catalysts</b><span>${dec.strong.length}</span></div>
          <div class="box"><b>avgTopK</b><span>${round2(dec.avgTopK)} (min ${round2(RUNTIME.minAvgTrade01)})</span></div>
        </div>
        <div class="hr"></div>
        ${reasons}
      </div>
    `;

    const picks = (scan.topPicks || []).slice(0,3);

    const picksBlock = picks.length ? picks.map((p, idx) => {
      const itype = getInstrumentType(p.ticker);
      const drivers = (p.drivers || []).map(d => {
        const when = d.seenDate ? fmtDate(new Date(d.seenDate), tz) : "";
        return `
          <div class="sub" style="margin-top:6px;">
            <span class="badge"><span class="dot ok"></span>+${round2(d.add)} driver</span>
            <span>${escapeHtml(d.topicKey)}</span>
            <a href="${escapeHtml(d.url)}" target="_blank" rel="noopener noreferrer">${escapeHtml(d.title)}</a>
            <span>${escapeHtml(when)}</span>
          </div>
        `;
      }).join("");

      const priceId = `price_${p.ticker}_${idx}`;
      const outId = `plan_${p.ticker}_${idx}`;

      return `
        <div class="item">
          <div class="title">${idx+1}) ${escapeHtml(p.ticker)} <span class="badge">${escapeHtml(p.group)}</span> <span class="badge">${itype}</span></div>
          <div class="sub">
            <span class="badge"><span class="dot ok"></span><b>Setup score:</b> ${p.score100}/100</span>
            <span class="badge"><b>Liq:</b> ${round2(p.liq)}</span>
            <span class="badge"><b>Vol:</b> ${round2(p.vol)}</span>
          </div>

          <div class="hr"></div>

          <div class="title">Discipline Trade Plan (manual price input)</div>
          <div class="row">
            <div>
              <label>Enter current price (USD)</label>
              <input id="${priceId}" type="number" step="0.01" placeholder="e.g., 39.25" />
            </div>
            <div>
              <label>Capital used (USD)</label>
              <input type="text" value="$${escapeHtml(String(el.capital.value || "1500"))}" disabled />
            </div>
          </div>
          <div id="${outId}" class="smallnote warnbox" style="margin-top:10px; padding:10px; border-radius:12px;">
            Enter a price to generate LIMIT entry + OCO exits + fees/tax math.
          </div>

          ${drivers ? `<div style="margin-top:10px;"><div class="sub"><b>Top drivers:</b></div>${drivers}</div>` : ""}
        </div>
      `;
    }).join("") : `
      <div class="item warnbox">
        <div class="title">No picks</div>
        <div class="smallnote">No candidates were scored. This usually means 0 trusted headlines were kept.</div>
      </div>
    `;

    el.viewDecision.innerHTML = header + picksBlock;

    picks.forEach((p, idx) => {
      const priceId = `price_${p.ticker}_${idx}`;
      const outId = `plan_${p.ticker}_${idx}`;
      const priceEl = document.getElementById(priceId);
      const outEl = document.getElementById(outId);
      if(!priceEl || !outEl) return;

      const instrumentType = getInstrumentType(p.ticker);

      const recalc = () => {
        const price = Number(priceEl.value);
        const cap = Number(el.capital.value || 1500);
        const stockTp = Number(el.stockTp.value || 22);

        const plan = computeTradePlan({ ticker: p.ticker, instrumentType, manualPrice: price, capitalUsd: cap, stockTpPct: stockTp });

        if(!plan.ok){
          outEl.className = "smallnote warnbox";
          outEl.style.marginTop = "10px";
          outEl.style.padding = "10px";
          outEl.style.borderRadius = "12px";
          outEl.innerHTML = escapeHtml(plan.error || "Enter inputs.");
          return;
        }

        const isETF = (instrumentType === "ETF");
        const entryStyle = isETF ? "Entry pullback: -0.3%" : "Entry pullback: -0.7%";

        outEl.className = "smallnote okbox";
        outEl.style.marginTop = "10px";
        outEl.style.padding = "10px";
        outEl.style.borderRadius = "12px";
        outEl.innerHTML = `
          <div class="sub">
            <span class="badge"><span class="dot ok"></span><b>${instrumentType}</b></span>
            <span class="badge"><b>Shares:</b> ${plan.shares}</span>
            <span class="badge"><b>Notional:</b> $${plan.notional}</span>
            <span class="badge"><b>Fees:</b> $${plan.fees}</span>
            <span class="badge"><b>Tax:</b> 25% gains</span>
          </div>
          <div class="smallnote" style="margin-top:8px;">
            <b>${entryStyle}</b> | TP ${(instrumentType==="ETF")?"+15%":("+"+Math.round((plan.tp/plan.entry-1)*100)+"%")} | SL ${(instrumentType==="ETF")?"-8%":"-10%"}
          </div>
          <div class="smallnote" style="margin-top:8px;">
            BUY LIMIT ${escapeHtml(p.ticker)}: <b>$${plan.entry}</b><br/>
            OCO exits:<br/>
            • Take-Profit LIMIT: <b>$${plan.tp}</b><br/>
            • Stop-Loss STOP-LIMIT: stop <b>$${plan.slStop}</b>, limit <b>$${plan.slLimit}</b><br/>
            Time stop: <b>${plan.timeStop}</b>.
          </div>
          <div class="smallnote" style="margin-top:8px;">
            TP scenario (net): gross $${plan.tpStats.gross}, tax $${plan.tpStats.tax}, fees $${plan.fees} → <b>$${plan.tpStats.netAfterTax}</b><br/>
            SL scenario (net): gross $${plan.slStats.gross}, fees $${plan.fees} → <b>$${plan.slStats.netAfterTax}</b>
          </div>
        `;
      };

      priceEl.addEventListener("input", recalc);
    });
  }

  function renderAll(scan){
    el.meta.textContent = `Scan @ ${fmtDate(new Date(scan.createdAt), scan.opts.tz)} | trusted headlines: ${scan.countHeadlines} | decision: ${scan.decisionMetrics.decision}`;
    renderDecision(scan);
    renderHeadlines(scan);
    renderTickers(scan);
    renderDiagnostics(scan);
    renderMethod();
  }

  const STORAGE_KEY = "trade_scanner_history_v8";
  const DOMAINS_KEY = "trade_scanner_trusted_domains_v3";
  const PRESET_KEY = "trade_scanner_domain_preset_v2";
  const MATCH_KEY = "trade_scanner_domain_match_v2";
  const OVER_KEY = "trade_scanner_oversample_v1";

  function loadHistory(){
    try { return JSON.parse(localStorage.getItem(STORAGE_KEY) || "[]"); }
    catch { return []; }
  }

  function saveHistory(arr){
    localStorage.setItem(STORAGE_KEY, JSON.stringify(arr.slice(0, 30)));
  }

  function refreshHistoryDropdown(){
    const arr = loadHistory();
    el.history.innerHTML = "";
    const opt0 = document.createElement("option");
    opt0.value = "";
    opt0.textContent = "— Select saved scan —";
    el.history.appendChild(opt0);

    for(let i=0;i<arr.length;i++){
      const s = arr[i];
      const o = document.createElement("option");
      o.value = String(i);
      const dt = new Date(s.createdAt);
      const top = (s.topPicks || []).map(x=>x.ticker).join(", ");
      o.textContent = `${i+1}) ${dt.toLocaleString()} | Top: ${top || "—"}`;
      el.history.appendChild(o);
    }
  }

  function clearHistory(){
    localStorage.removeItem(STORAGE_KEY);
    refreshHistoryDropdown();
    setStatus("History cleared.");
  }

  function saveCurrent(){
    if(!lastScan) return;
    const arr = loadHistory();
    arr.unshift(lastScan);
    saveHistory(arr);
    refreshHistoryDropdown();
    setStatus("Saved to History.");
  }

  function exportJson(){
    if(!lastScan) return;
    const blob = new Blob([JSON.stringify(lastScan, null, 2)], { type:"application/json" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = `scan_${new Date(lastScan.createdAt).toISOString().replaceAll(":","-")}.json`;
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  }

  function loadFromHistoryIndex(idx){
    const arr = loadHistory();
    const scan = arr[idx];
    if(!scan) return;
    lastScan = scan;
    setStatus("Loaded saved scan (no re-fetch).");
    renderAll(scan);
    el.saveBtn.disabled = false;
    el.exportBtn.disabled = false;
  }

  function loadDomainsFallback(){ return PRESET_EXPANDED.slice(); }

  function loadDomains(){
    const raw = localStorage.getItem(DOMAINS_KEY);
    if(!raw) return loadDomainsFallback();
    try{
      const arr = JSON.parse(raw);
      return Array.isArray(arr) && arr.length ? arr : loadDomainsFallback();
    }catch{
      return loadDomainsFallback();
    }
  }

  function saveDomains(domains){ localStorage.setItem(DOMAINS_KEY, JSON.stringify(domains)); }

  function applyPresetToTextarea(preset){
    const domains = getPresetDomains(preset);
    el.trustedDomains.value = domains.join("\n");
    saveDomains(domains);
  }

  function persistDomainsFromUI(){
    const domains = parseDomains(el.trustedDomains.value);
    if(domains.length < 5){
      setStatus("Domain list too small. Choose a preset or add more trusted domains.", true);
      return;
    }
    saveDomains(domains);
    setStatus(`Saved trusted domains (${domains.length}).`);
  }

  async function runScan(){
    applyStrictnessFromUI();
    setStatus("");

    el.runBtn.disabled = true;
    el.saveBtn.disabled = true;
    el.exportBtn.disabled = true;

    const allowlist = parseDomains(el.trustedDomains.value);
    if(allowlist.length < 5){
      setStatus("Trusted domains list is empty/too small. Reset to a preset and try again.", true);
      el.runBtn.disabled = false;
      return;
    }

    const perTopic = Math.max(1, Math.min(25, Number(el.perTopic.value || 5)));
    const oversample = Math.max(2, Math.min(10, Number(el.oversample.value || 6)));
    const maxrecords = Math.max(perTopic, Math.min(250, perTopic * oversample)); // keep under a sane cap

    const opts = {
      timespan: el.timespan.value,
      sort: el.sort.value,
      perTopic,
      concurrency: Math.max(1, Math.min(10, Number(el.concurrency.value || 4))),
      tz: el.tz.value || "Asia/Jerusalem",
      country: (el.country.value || "").trim(),
      customQuery: el.customQuery.value || "",
      trustedDomains: allowlist,
      domainPreset: el.domainPreset.value,
      domainMatch: el.domainMatch.value,
      oversample,
      maxrecords
    };

    setPills([
      ["timespan", opts.timespan],
      ["sort", opts.sort || "relevance"],
      ["perTopic", perTopic],
      ["oversample", "x"+oversample],
      ["maxrecords", maxrecords],
      ["lang", "english (locked)"],
      ["domains", allowlist.length],
      ["match", opts.domainMatch]
    ]);

    setStatus("Fetching GDELT (English-only), then filtering to trusted domains…");

    const nowUtc = new Date();

    let byTopic;
    try{
      byTopic = await mapLimit(TOPICS, opts.concurrency, async (topic) => {
        try{
          const r = await fetchTopic(topic, opts);
          return { ...r, error: null };
        }catch(e){
          return { topicKey: topic.key, topicLabel: topic.label, query: "", url: "", articles: [], error: String(e.message || e) };
        }
      });
    }catch(e){
      setStatus(String(e.message || e), true);
      el.runBtn.disabled = false;
      return;
    }

    let rawFetched = 0;
    let trustedKeptTotal = 0;
    let droppedUntrustedTotal = 0;

    const all = [];
    const scoredByTopic = byTopic.map(t => {
      const fetched = (t.articles || []).length;
      rawFetched += fetched;

      const trusted = (t.articles || []).filter(a => domainAllowed(a.domain || "", allowlist, opts.domainMatch));
      const dropped = fetched - trusted.length;
      trustedKeptTotal += trusted.length;
      droppedUntrustedTotal += dropped;

      const trimmed = trusted.slice(0, perTopic);

      const items = trimmed.map(a => {
        const title = a.title || "(no title)";
        const url = a.url || a.url_mobile || "#";
        const domain = a.domain || "";
        const seenDateObj = parseGdeltSeenDate(a.seendate || a.seenDate || "");

        const { score10, trade01, clarity, timing } = headlineImpactScore({ topicKey: t.topicKey, title, seenDate: seenDateObj }, nowUtc);
        const soft = isSoftHeadline(title);

        const h = {
          topicKey: t.topicKey, topicLabel: t.topicLabel,
          title, url, domain,
          seenDate: seenDateObj ? seenDateObj.toISOString() : null,
          score10, trade01, clarity, timing, soft
        };
        all.push(h);
        return h;
      });

      return {
        topicKey: t.topicKey,
        topicLabel: t.topicLabel,
        query: t.query,
        url: t.url,
        error: t.error,
        fetchedCount: fetched,
        trustedKept: trusted.length,
        droppedUntrusted: dropped,
        items
      };
    });

    const decisionMetrics = computeDecisionMetrics(all);
    const scoringHeadlines = RUNTIME.ideaMode ? all : decisionMetrics.kept;

    const { tickerTable, groupShares } = aggregateTickerScores(scoringHeadlines);
    const topPicks = tickerTable.slice(0, 3);

    const scan = {
      createdAt: nowUtc.toISOString(),
      opts,
      rawFetched,
      trustedKeptTotal,
      droppedUntrustedTotal,
      byTopic: scoredByTopic,
      countHeadlines: all.length,
      decisionMetrics,
      tickerTable,
      groupShares,
      topPicks
    };

    lastScan = scan;

    const errCount = scoredByTopic.filter(x=>x.error).length;
    if(all.length === 0){
      setStatus("0 trusted headlines kept. Increase lookback, oversample, or broaden domain matching.", true);
    } else if(errCount){
      setStatus(`Completed with ${errCount} topic errors (see Headlines tab).`, true);
    } else {
      setStatus("Completed.");
    }

    renderAll(scan);
    el.runBtn.disabled = false;
    el.saveBtn.disabled = false;
    el.exportBtn.disabled = false;
  }

  document.querySelectorAll(".tab").forEach(t=>{
    t.addEventListener("click", () => setActiveTab(t.dataset.tab));
  });

  el.strictness.addEventListener("input", applyStrictnessFromUI);
  el.runBtn.addEventListener("click", runScan);
  el.saveBtn.addEventListener("click", saveCurrent);
  el.exportBtn.addEventListener("click", exportJson);
  el.clearHistoryBtn.addEventListener("click", clearHistory);

  el.history.addEventListener("change", () => {
    const v = el.history.value;
    if(!v) return;
    loadFromHistoryIndex(Number(v));
  });

  el.resetDomainsBtn.addEventListener("click", () => {
    const preset = el.domainPreset.value;
    if(preset === "custom"){
      el.domainPreset.value = "expanded";
      localStorage.setItem(PRESET_KEY, "expanded");
      applyPresetToTextarea("expanded");
    } else {
      applyPresetToTextarea(preset);
    }
    setStatus("Reset to preset domains.");
  });

  el.saveDomainsBtn.addEventListener("click", persistDomainsFromUI);

  el.domainPreset.addEventListener("change", () => {
    const p = el.domainPreset.value;
    localStorage.setItem(PRESET_KEY, p);
    if(p !== "custom"){
      applyPresetToTextarea(p);
      setStatus("Applied preset domains.");
    } else {
      setStatus("Custom mode: edit domains and click Save List.");
    }
  });

  el.domainMatch.addEventListener("change", () => localStorage.setItem(MATCH_KEY, el.domainMatch.value));
  el.oversample.addEventListener("change", () => localStorage.setItem(OVER_KEY, el.oversample.value));

  function init(){
    refreshHistoryDropdown();
    applyStrictnessFromUI();
    setActiveTab("decision");
    renderMethod();

    const savedPreset = localStorage.getItem(PRESET_KEY);
    if(savedPreset && ["expanded","core","official","custom"].includes(savedPreset)){
      el.domainPreset.value = savedPreset;
    }
    const savedMatch = localStorage.getItem(MATCH_KEY);
    if(savedMatch && ["broad","exact"].includes(savedMatch)){
      el.domainMatch.value = savedMatch;
    }
    const savedOver = localStorage.getItem(OVER_KEY);
    if(savedOver && ["4","6","8","10"].includes(savedOver)){
      el.oversample.value = savedOver;
    }

    if(el.domainPreset.value !== "custom"){
      applyPresetToTextarea(el.domainPreset.value);
    } else {
      el.trustedDomains.value = loadDomains().join("\n");
    }
  }

  init();
})();
</script>
</body>
</html>
